<?xml version="1.0" encoding="UTF-8"?>
<?hotspot layout-path="hotspot/hotspot/layout" ?>
<?hotspot kilauea-path="hotspot/kilauea" ?>
<?hotspot layout="ischool" ?>
<hotspot xmlns="http://dret.net/xmlns/hotspot/1" xmlns:hotspot="http://dret.net/xmlns/hotspot/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://dret.net/xmlns/hotspot/1 hotspot/hotspot/schemas/hotspot.xsd">
	<configuration>
		<link subsections="yes" bookmarks="yes" versions="xml-fall13.xml" home="./" help="quick" contents="./" author="http://dret.net/netdret/"/>
		<paths img="img" listing="src"/>
		<outline count-text=" [*]" count-depth="all"/>
		<hyperlink extra=""/>
		<extension file="html" link=""/>
		<counter separator=":&#160;"/>
		<kilauea xmlns="http://xmlns.sharpeleven.net/kilauea">
			<plugins>
				<touch/>
			</plugins>
		</kilauea>
	</configuration>
	<license uri="http://creativecommons.org/licenses/by/3.0/" short="CC 3.0">
		<div class="license">
			<p><a rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" src="hotspot/hotspot/layout/ischool/ischool/somerights20.png" border="0" height="31" width="88"/></a></p>
			<p><a class="outlink" rel="license" title="view full text of license" href="http://creativecommons.org/licenses/by/3.0/">This work is licensed under a CC<br/>Attribution 3.0 Unported License</a></p>
		</div>
	</license>
	<title short="XML Foundations"><a href="./" title="Course Homepage">XML Foundations</a><br/>Fall 2013 &#x2014; INFO 242 (CCN 41613)</title>
	<author short="E. Wilde" affiliation="UC Berkeley ISchool"><a href="http://dret.net/netdret/">Erik Wilde</a></author>
	<affiliation short="UC Berkeley ISchool"><a href="http://www.berkeley.edu/" title="University of California, Berkeley">UC Berkeley</a> <a href="http://ischool.berkeley.edu/" title="ISchool">School of Information</a></affiliation>
	<date short="Fall 2013">Fall Semester 2013</date>
	<copyright>2013 Erik Wilde</copyright>
	<categories>
		<category element="xml" class="xml" name="XML"/>
		<category element="elem" class="xml elem" name="XML Element"/>
		<category element="html" class="html" name="HTML"/>
		<category element="htmla" class="html" name="HTML Attribute"/>
		<category element="htmel" class="html elem" name="HTML Element"/>
		<category element="cssp" class="css" name="CSS Property"/>
		<category element="csss" class="css" name="CSS Selector"/>
		<category element="css" class="css" name="CSS"/>
		<category element="xlink" class="xml" name="XLink"/>
		<category element="xpathf" class="xpath" name="XPath Function"/>
		<category element="xpath" class="xpath" name="XPath"/>
		<category element="xslte" class="xslt elem" name="XSLT Element"/>
		<category element="xslta" class="xslt" name="XSLT Attribute"/>
		<category element="xslt" class="xslt" name="XSLT"/>
		<category element="xsde" class="xsd elem" name="XSD Element"/>
		<category element="xsda" class="xsd" name="XSD Attribute"/>
		<category element="xsd" class="xsd" name="XSD"/>
		<category element="xq" class="xq" name="XQuery"/>
		<category element="uri" class="uri" name="URI"/>
		<category element="http" class="http" name="HTTP"/>
		<category element="mime" class="mime" name="MIME"/>
		<category element="atom" class="atom" name="Atom"/>
	</categories>
	<toc name="toc.html">
		<table rules="all" cellspacing="0" cellpadding="5" width="100%">
			<thead>
				<tr>
					<th valign="bottom">Date</th>
					<th valign="bottom">Subject</th>
					<th valign="bottom">Slides</th>
					<th valign="bottom">Additional Resources</th>
					<!-- <th valign="bottom"><a href="a/">Assignments</a></th> -->
				</tr>
			</thead>
			<tbody>
				<hotspot:for-each-presentation>
					<tr class="vevent">
						<td align="right" valign="top"><hotspot:date/></td>
						<td valign="top">
							<hotspot:if-toc class="author">
								<span class="guest">Guest Lecture by <hotspot:toc class="author"/> : </span>
							</hotspot:if-toc>
							<b><span class="summary"><hotspot:title/></span><span class="toggle">:</span></b> <span class="toggle"><span class="description"><hotspot:toc class="abstract"/></span></span>
							<div style="display : none">
								<span class="dtstart"><hotspot:date/>T09:00</span>
								<span class="dtend"><hotspot:date/>T10:30</span>
								<span class="location">205 South Hall, UC Berkeley</span>
							</div>
						</td>
						<td align="center"><hotspot:presentation-link title="Lecture Slides"><hotspot:title form="short"/></hotspot:presentation-link> <span class="toggle"><hotspot:slides>(*&#160;Slides)</hotspot:slides></span></td>
						<td align="center"><hotspot:toc class="resources"/></td>
						<!-- <td align="center"><hotspot:toc class="assignment"/></td> -->
					</tr>
				</hotspot:for-each-presentation>
			</tbody>
		</table>
	</toc>
	<presentation id="intro">
		<title short="Introduction">Overview and Introduction</title>
		<date>2013-09-04</date>
		<toc class="resources"><a href="http://www.w3.org/Press/1998/XML10-REC">XML 1.0 Press Release</a>&#160;· <a href="http://www.tbray.org/ongoing/When/200x/2008/02/10/XML-People" title="Tim Bray: XML People">XML People</a></toc>
		<toc class="abstract">The <em>Extensible Markup Language (XML)</em> has been introduced in 1998 to enable content providers to publish their content on the Web in an application-specific format. HTML was considered as conveying not enough semantics, since its only purpose was (and is) the preparation of content for Web-based publishing. XML was the first step towards machine-readable data formats for the Web, a trend that since its invention has been taken to higher levels with the idea of the <em>Semantic Web</em>. XML appeared when the Web was in the steepest part of its success curve, and since then has taken over as the globally accepted format for the exchange of machine-readable structured data.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Varia</title>
			<slide id="dret-info">
				<title>About Me</title>
				<ul>
					<li>Erik Wilde exists on <a href="http://dret.net/netdret/">the Web</a>, <a href="https://twitter.com/dret" title="@dret">Twitter</a>, <a href="http://www.flickr.com/photos/dret/">Flickr</a>, and <a href="http://dret.typepad.com/dretblog/" title="dretblog">his blog</a></li>
					<li>Computer Science in <a href="http://www.tu-berlin.de/eng/" title="Technical University of Berlin (TUB)">Berlin</a>, Ph.D. in <a href="http://www.ethz.ch/index_EN" title="Swiss Federal Institute of Technology">Zürich</a></li>
					<li>Post-Doc at <a href="http://www.icsi.berkeley.edu/" title="International Computer Science Institute">ICSI</a>, Berkeley (1997/98)</li>
					<li>Various activities in Switzerland (1998-2006)</li>
					<ul>
						<li>teaching at <a href="http://www.ethz.ch/index_EN">ETH Zürich</a> and <a href="http://www.fhnw.ch/">FHNW</a></li>
						<li>working as independent consultant (training, courses, consulting)</li>
						<li>research in <a href="http://dret.net/projects/">various XML-related areas</a></li>
					</ul>
					<li>Professor at the <a href="http://ischool.berkeley.edu/">School of Information</a> (2006-11)</li>
					<ul>
						<li>Technical Director of the <a href="http://isd.ischool.berkeley.edu/">Information and Service Design (ISD) program</a></li>
					</ul>
					<li>Architect at <a href="http://www.emc.com/">EMC</a>'s <a href="http://web.emc.com/informationintelligence">Information Intelligence Group (IIG)</a> (since 2011)</li>
					<ul>
						<li>providing guidance and guidelines for IIG's RESTful SOA</li>
					</ul>
				</ul>
			</slide>
			<slide id="course-info">
				<title>About this Course</title>
				<ul>
					<li>Course Web page: <code><a href="./">http://dret.net/lectures/xml-fall13/</a></code></li>
					<li>All sources (XML/examples/images) <a href="https://github.com/dret/lectures/tree/master/xml-fall13">available at GitHub</a></li>
					<li>Course mailing list: <code><a href="mailto:xml-fall13@bspace.berkeley.edu">xml-fall13@bspace.berkeley.edu</a></code></li>
					<ul>
						<li>archived in the <a href="https://bspace.berkeley.edu/portal/site/9a83055f-77a0-4627-a276-ece16c98f8e2">bSpace</a> <a href="https://bspace.berkeley.edu/portal/site/9a83055f-77a0-4627-a276-ece16c98f8e2/page/a1285cb7-16ec-441b-8b81-efa4bbc03831">email archive</a></li>
					</ul>
					<li>Grading is based on assignments and final exam</li>
					<ul>
						<li>25% split evenly across all assignments (grading per team)</li>
						<li>25% final <q>project report</q> (graded individually)</li>
						<li>50% final exam (30min oral, taken/graded individually)</li>
					</ul>
				</ul>
			</slide>
			<slide id="slide-info">
				<title>About these Slides</title>
				<ul>
					<li>Generated from <a href="http://dret.net/projects/xslidy/">Hotspot</a> <a href="xml-fall13.xml">XML</a></li>
					<li>Designed for online presentation and use (lots of links!)</li>
					<ul>
						<li>for printing, use <q>a</q> (all slides), and then <q>s</q> (smaller font) a couple of times</li>
					</ul>
					<li>A good real-world example for XML applications</li>
					<ul>
						<li>Slidy/Kilauea is useful, but there is no support for structures and hyperlinking</li>
						<li>Hotspot adds these features by adding an XSLT transformation</li>
						<li>Hotspot is useful, but there is no interface (XML editing only)</li>
					</ul>
				</ul>
			</slide>
			<slide id="resource-info">
				<title>Additional Resources</title>
				<ul>
					<li><a href="http://dret.net/biblio/">Bibliography at <code>http://dret.net/biblio/</code></a></li>
					<ul>
						<li>suggestions, updates, corrections are very welcome (really!)</li>
					</ul>
					<li>The <a href="http://www.w3.org/"><em>World Wide Web Consortium (W3C)</em></a></li>
					<ul>
						<li>the organization which invented XML</li>
						<li>as well as (almost) all other technologies covered in this course</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="why-xml">
			<title>Why/How/Where XML is Useful</title>
			<slide>
				<title>XML is a Metalanguage</title>
				<ul>
					<li>XML can be used to represent any kind of structured data</li>
					<ul>
						<li>(as long as the data is modeled in a way that fits XML's metamodel)</li>
					</ul>
					<li>XQuery and XSLT can be used to process XML documents</li>
					<ul>
						<li>(or use the language of your choice and XML libraries)</li>
					</ul>
					<li>XML formats can be designed to be flexible and extensible</li>
					<ul>
						<li>(this requires good modeling skills <em>and</em> good XML skills)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>GPS Track Visualization</title>
				<img src="marin-run-map.png" style="height : 70% ; margin : 2% ; " href="http://app.strava.com/activities/18200957"/>
			</slide>
			<slide>
				<title>GPS Track in XML</title>
				<ul>
					<li><a href="http://app.strava.com/activities/39586316">GPS data</a> exported to <a href="http://www.topografix.com/gpx/1/1/">GPX format</a></li>
				</ul>
				<listing src="2010-01-15-1.gpx" line="1-21"/>
			</slide>
			<slide>
				<title>GPS Track Combination</title>
				<img src="heatmap-golden-gate.png" style="height : 70% ; margin : 2% ; " href="http://x.raceshape.com/heatmap/view.html?id=r1ycR0%2Fhp88VjX%2FAVO4B3gHo%2B9gyzOuMQA1uDqCn"/>
			</slide>
			<slide>
				<title>Finding Activities (Saxon)</title>
				<listing src="find-by-location-oxygen.xq"/>
			</slide>
		</part>
		<part>
			<title>Data Formats? Databases?</title>
			<part>
				<title>Alternatives to XML</title>
				<slide id="xml-and-csv">
					<title>XML and CSV</title>
					<ul>
						<li>CSV is easier to understand and use</li>
						<li>CSV tools (such as <em>Excel</em>) are widely used and understood</li>
						<li>Structures beyond tables are hard to represent</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
				<slide id="xml-and-json">
					<title>XML and JSON</title>
					<ul>
						<li><link href="json">JSON</link> maps better into most programming languages</li>
						<li>JSON objects can be readily used as language objects</li>
						<li>Structures beyond nested objects/arrays are hard to represent</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
				<slide id="xml-and-rdf">
					<title>XML and RDF</title>
					<ul>
						<li><link href="rdf">RDF</link> does not have the built-in <q>tree bias</q> of XML</li>
						<li>RDF can be combined more easily across <q>documents</q></li>
						<li>Data that has some <q>natural coherence</q> is hard to manage</li>
						<li>Document structures are impossible to represent</li>
					</ul>
				</slide>
			</part>
			<part>
				<title>XML Big Data</title>
				<slide>
					<title>XML and Databases</title>
					<ul>
						<li>A data format defines a framework for certain kinds of data</li>
						<ul>
							<li>some formats are <em>metalanguages</em> such as XML, but most are not</li>
						</ul>
						<li>A database is based on a <em>data model</em> and manages data as well as access</li>
						<li>XML does not talk about databases at all</li>
						<li>It is possible to build databases that support XML's model</li>
						<ul>
							<li>data storage can be scaled beyond what file systems can manage</li>
							<li>access to XML can be much better optimized in XML databases</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XQuery using Files</title>
					<img style="width : 86% ; margin : 4% ; " src="xquery-overview-filesystem.png" title="File-based XQuery Processing"/>
				</slide>
				<slide>
					<title>XQuery using an XML Database</title>
					<img style="width : 86% ; margin : 4% ; " src="xquery-overview-dbms.png" title="DB-based XQuery Processing"/>
				</slide>
				<slide>
					<title>Moving Data into a Database</title>
					<img src="xDB-import.png" style="height : 70% ; margin : 2% ; " href="http://developer.emc.com/docs/documentum/xdb/manual/index.html#doc:task/adminclient_importing_data.html"/>
				</slide>
				<slide>
					<title>Finding Activities (xDB)</title>
					<listing src="find-by-location-xdb.xq"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XML is a Hammer</title>
				<ul>
					<li>XML is just one way to represent structured data</li>
					<li>Like all models/metamodels, XML has limitations and side-effects</li>
					<li>XML's tool chain allow to adapt to a variety of scenarios</li>
					<li>XML databases support scalable access to <q>XML Big Data</q></li>
					<li>As with all tools: know the tool, know the alternatives</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="basics">
		<title short="Basics">XML Basics</title>
		<date>2013-09-09</date>
		<toc class="resources"><a href="http://www.w3.org/TR/REC-xml/" title="W3C XML 1.0 Specification">XML&#160;1.0&#160;Spec</a>&#160;· <a href="http://dret.net/netdret/docs/wilde-cacm2008-xml-fever.html" title='Erik Wilde and Robert J. Glushko, "XML Fever", Communications of the ACM, 51(7):40-46, July 2008'>XML&#160;Fever</a></toc>
		<toc class="abstract">The <em>Extensible Markup Language (XML)</em> defines a simple way for structuring data. The power and popularity of XML can be explained by its versatility, the platform-independence, the standards and technologies leveraging it, and the number of tools and products supporting it. Understanding XML itself is rather simple, as it only depends on a very small set of other technologies. Unicode is the most important foundation of XML. XML itself specifies two different things: on the one hand the format for structured data, which are called <em>XML documents</em>, and on the other hand a constraint language for XML documents, which is called <em>Document Type Definition (DTD)</em>.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Foundations for XML</title>
			<slide>
				<title>Identifications</title>
				<ul>
					<li>Identification of Character Encodings</li>
					<ul>
						<li>text can be encoded using different character sets and encodings</li>
						<li>IANA maintains the <a href="http://www.iana.org/assignments/character-sets">official list of character encodings</a></li>
						<li>character encoding is about <em>characters</em>, not about <em>text</em></li>
					</ul>
					<li>Identification of Languages</li>
					<ul>
						<li>textual content should be tagged with language information</li>
						<li>specification based on <a href="http://www.loc.gov/standards/iso639-2/langhome.html">ISO 639 language tags</a></li>
						<li>language identification is about <em>text</em>, not about <em>characters</em></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XML's Idea of Content and Names</title>
				<p>XML documents can use a wide array of characters. They are defined by <a href="http://www.unicode.org/">Unicode</a>, which currently (Version 5.0) defines more than 100'000 characters (#100'000 added in 2005).</p>
				<listing src="japanese1.xml"/>
				<listing src="japanese2.xml"/>
			</slide>
			<slide>
				<title>XML and Unicode</title>
				<ul>
					<li>XML is based on Unicode</li>
					<ul>
						<li>XML is defined in terms of <a href="http://www.w3.org/TR/xml/#sec-starttags">character structures</a></li>
						<li>how these characters are encoded is not part of XML</li>
					</ul>
					<li>How are XML documents encoded?</li>
					<ul>
						<li>applications can use any character encoding they like</li>
						<li>XML processors <em>must</em> support UTF-8 and UTF-16</li>
						<li>XML processors <em>may</em> support any number of additional encodings</li>
					</ul>
					<li>How is the encoding <q>encoded</q>?</li>
					<ul>
						<li>part of the XML document: <code>&lt;?xml version="1.0" encoding="UTF-8"?></code></li>
						<li>bootstrap problem solved heuristically or by out-of-band information</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>XML</title>
			<slide>
				<title>XML Use Cases</title>
				<ul>
					<li>XML is a metalanguage supporting application-specific vocabularies</li>
					<li><em>RSS</em> (and <em>Atom</em>) are XML vocabularies for newsfeeds</li>
					<ul>
						<li><a href="http://docordie.blogspot.com/">Doc or Die</a>: <a href="http://docordie.blogspot.com/rss.xml">RSS feed</a> vs. <a href="http://docordie.blogspot.com/atom.xml">Atom feed</a></li>
						<li>browsers now incorporate and/or integrate newsfeed readers</li>
					</ul>
					<li><em>OpenDocument (ODF)</em> is a language for office application documents</li>
					<ul>
						<li>designed for open and interoperable exchange</li>
						<li>standardized by ISO (which now also standardizes Microsoft's <em>Open XML</em>)</li>
					</ul>
					<li><em>Scalable Vector Graphics (SVG)</em> for portable vector graphics</li>
					<ul>
						<li>designed for embedding in Web pages</li>
						<li>good example for compound documents: <a href="http://www.carto.net/papers/svg/animated_weather_symbols/">HTML containing SVG</a></li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>XML Documents</title>
				<slide>
					<title>Markup?</title>
					<ul>
						<li>Structures are encoded using special characters</li>
						<ul>
							<li>a fundamental difference when comparing to binary formats</li>
							<li>markup languages can be read and modified using text-based tools</li>
							<li>programs must treat markup characters in a special way</li>
						</ul>
						<li>Documents are content interspersed with markup (i.e., structures)</li>
						<ul>
							<li>XML-aware software interprets the markup</li>
							<li>XML-unaware software just sees a text file</li>
							<li>modifications must be made XML-aware (e.g., inserting <q>AT&amp;T</q> as <q>AT&amp;amp;T</q>)</li>
						</ul>
						<li>You have to pay the <link href="markup-price"/></li>
					</ul>
				</slide>
				<slide>
					<title>Basic Concepts</title>
					<ul>
						<li>XML Documents have an <em>XML declaration</em> (optional)</li>
						<li>There is exactly one <em>document element</em> (a.k.a. <em>root element</em>)</li>
						<li>Elements may be nested (there is no conceptual limit)</li>
						<ul>
							<li>elements may be repeated (they can be identified by position)</li>
						</ul>
						<li>Elements are marked up using <em>tags</em></li>
						<ul>
							<li>most elements have content, surrounded by <em>start</em> and <em>end tags</em></li>
							<li>empty elements are allowed and may use a special notation</li>
						</ul>
						<li>Elements may have attributes (zero to any number)</li>
						<ul>
							<li>attributes can only occur once on an element (i.e., they cannot be repeated)</li>
						</ul>
					</ul>
					<listing src="my-first.xml"/>
				</slide>
				<slide id="xmltree">
					<title>Tree Syntax</title>
					<ul>
						<li>Markup is important, but only a notation</li>
						<li>XML documents are trees with different node types</li>
						<ul>
							<li>nodes so far: document, element, attribute, text</li>
						</ul>
						<img style="width : 90% ; margin : 4% ;" src="document-tree.png" title="XML document tree"/>
					</ul>
				</slide>
				<slide id="xmlelements">
					<title>Elements</title>
					<ul>
						<li>Elements can use a <a href="http://www.w3.org/TR/xml/#NT-Name">wide variety of names</a></li>
						<ul>
							<li>Allowed: <elem>html</elem>, <elem>id9832798472</elem>, <elem>_</elem>, <elem>:</elem>, <elem>こんにちは</elem></li>
							<li>Disallowed: leading numbers, spaces, control characters</li>
						</ul>
						<li>Element names usually convey some information about the content</li>
						<ul>
							<li>this is not reliable and highly language-dependent</li>
							<li>it is <em>very useful</em> when working with a known vocabulary</li>
							<li>it is <em>potentially harmful</em> when working with an unknown vocabulary</li>
						</ul>
						<li>Elements are the foundation for XML's versatility</li>
						<ul>
							<li>they can be nested (<code>&lt;address>&lt;city>Berkeley&lt;/city>&lt;zip>94709&lt;/zip>…</code>)</li>
							<li>they can be repeated (<code>&lt;givenname>Erik&lt;/givenname>&lt;givenname>Thomas&lt;/givenname></code>)</li>
							<li>their sequence can convey additional information (given names have a sequence)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Attributes</title>
					<ul>
						<li>Additional information pertaining to elements</li>
						<li>Traditionally, anything that is not considered <q>content</q></li>
						<ul>
							<li>SGML is a document markup language</li>
							<li>XML uses SGML's concepts</li>
							<li>XML has its roots in the document world</li>
						</ul>
						<li>Elements: Content (i.e., Data); Attributes: Metadata</li>
						<li>Documents often distinguish by what is textual content</li>
					</ul>
					<listing src="section.xml" line="12-20"/>
				</slide>
				<slide>
					<title>Attribute Syntax</title>
					<ul>
						<li>Naming rules are the same as for <link href="xmlelements"/></li>
						<li>Attributes always appear within an element's <em>start tag</em></li>
						<li>Attributes are <a href="http://www.w3.org/TR/xml/#NT-Attribute">name/value-pairs</a></li>
						<ul>
							<li>the value is enclosed in single or double quotes</li>
						</ul>
						<li>Attribute with a single-quote value: <elem>elem attr="Single: '"/</elem></li>
						<li>Attribute with a double-quote value: <elem>elem attr='Double :"'/</elem></li>
						<li>How can attribute values contain both?</li>
					</ul>
				</slide>
				<slide id="markup-price">
					<title>The Price for Markup</title>
					<ul>
						<li>Markup characters have a special meaning</li>
						<ul>
							<li><q>&lt;</q> opens a tag</li>
							<li>for attribute values, quotes delimit the value</li>
						</ul>
						<li>The literal use of a markup character requires escaping</li>
						<ul>
							<li>XML's <em>entities</em> can refer to pieces of content</li>
							<li>entity syntax is <code>&amp;name;</code> for referring to the entity <q><code>name</code></q></li>
							<li>XML has 5 <a href="http://www.w3.org/TR/xml/#sec-predefined-ent">predefined entities</a>: <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;apos;</code>, <code>&amp;quot;</code></li>
						</ul>
						<li>Attribute using both kinds of quotes: <code>&lt;elem attr="Single ' and Double &amp;quot;"/></code></li>
					</ul>
					<pre><![CDATA[<li>Attribute using both kinds of quotes: <code>&lt;elem attr="Single ' and Double &amp;quot;"/></code></li>]]></pre>
				</slide>
				<slide id="mixed-content">
					<title>Mixed Content</title>
					<p>The term <em>Mixed content</em> in XML refers to elements <a href="http://www.w3.org/TR/xml/#sec-mixed-content">which have text content mixed with elements</a>. What these elements do depends on the elements <img style="height : 1em" src="smiley.gif"/>, but the important point is that they are on the same level as the text nodes of the mixed content.</p>
					<pre><![CDATA[<p>The term <em>Mixed content</em> in XML refers to elements <a href="http://www.w3.org/TR/xml/#sec-mixed-content">which have text content mixed with elements</a>. What these elements do depends on the elements <img style="height : 1em" src="smiley.gif"/>, but the important point is that they are on the same level as the text nodes of the mixed content.</p>]]></pre>
					<img style="width : 90% ; margin : 4% ;" src="mixed-content.png" title="XML tree for mixed content"/>
				</slide>
				<slide>
					<title>Mixed Content Usage</title>
					<ul>
						<li>Database people find mixed content irritating</li>
						<ul>
							<li>cannot be easily mapped to relational structures</li>
							<li>is more <em>document-like</em> than <em>data-like</em></li>
							<li>much harder to optimize for query analysis and query processing</li>
						</ul>
						<li>Document people find mixed content very intriguing</li>
						<ul>
							<li>textual content can still be used as simple text</li>
							<li>markup provides additional information for rich text</li>
							<li>start with a text-only document and use markup to add structure to it</li>
						</ul>
					</ul>
				</slide>
				<slide id="whitespace">
					<title>Whitespace</title>
					<ul>
						<li>XML documents often are pretty-printed</li>
						<li><em>Whitespace text nodes</em> often are <q>not really content</q></li>
						<ul>
							<li>XML whitespace characters are <em>space</em>, <em>tab</em>, <em>newline</em>, and <em>carriage return</em></li>
							<li>whitespace text nodes are text nodes containing <em>only</em> whitespace characters</li>
						</ul>
						<img style="width : 90% ; margin : 4% ;" src="document-tree-whitespace.png" title="XML tree with whitespace text nodes"/>
					</ul>
				</slide>
				<slide>
					<title>Significant Whitespace</title>
					<ul>
						<li>Some whitespace text nodes are relevant</li>
						<li>Usually text nodes in <em>mixed content</em> elements</li>
					</ul>
					<p>Whitespace <i>can be</i> <u>very</u> <b>important</b>!</p>
					<pre><![CDATA[<p>Whitespace <i>can be</i> <u>very</u> <b>important</b>!</p>]]></pre>
					<img style="height : 40% ; margin : 2% ;" src="significant-whitespace.png" title="XML tree containing significant whitespace"/>
				</slide>
			</part>
			<part id="wellformed">
				<title>Processing XML</title>
				<slide>
					<title>Observing XML Syntax</title>
					<ul>
						<li>XML's syntax requires you to use the right characters</li>
						<ul>
							<li><a href="http://www.w3.org/TR/xml/#NT-element">the grammar alone</a> allows many XML errors</li>
							<li><a href="http://www.w3.org/TR/xml/#GIMatch">additional constraints</a> ensure that everything is used correctly</li>
						</ul>
						<li><em>XML processors</em> (a.k.a. <em>XML parsers)</em> check for these rules</li>
						<ul>
							<li>if there are problems, the document cannot be interpreted as XML</li>
							<li>otherwise, the document is said to be <em>well-formed</em></li>
						</ul>
						<li>Only well-formed documents can be regarded as a tree</li>
						<ul>
							<li>other documents are not XML at all, even though they may be close</li>
							<li>XML processors must report problems to the application (no guessing allowed)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Validity</title>
					<ul>
						<li><em>Well-formed documents</em> observe XML rules</li>
						<ul>
							<li>they observe the XML syntax</li>
							<li>they observe all well-formedness constraints</li>
						</ul>
						<li>Applications require the right elements and attributes</li>
						<li><em>Validity</em> is a more comprehensive concept</li>
						<li><em>Valid documents</em> observe additional rules</li>
						<ul>
							<li>they must be well-formed documents</li>
							<li>they must adhere to the constraints defined in a schema (DTD, XSD, RNG, ...)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Semantics</title>
					<ul>
						<li>XML is a language for encoding trees</li>
						<ul>
							<li>Elements and attributes are labeled node in this tree</li>
							<li>the labels can be chosen freely by document authors</li>
						</ul>
						<li>The tree's meaning is nothing XML is concerned with</li>
						<ul>
							<li>peers must have a mutual understanding of the semantics</li>
							<li>XML without mutual understanding is almost useless</li>
							<li>reverse engineering often is possible, but it is risky and brittle</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XML Documents</title>
				<ul>
					<li>XML documents are structured data using markup</li>
					<li>Elements and Attributes are the main structuring mechanisms</li>
					<li>Elements and Attributes have names, but have no inherent semantics</li>
					<li>For using XML successfully, <em>shared semantics</em> are essential</li>
					<li>Always think about semantics</li>
				</ul>
			</slide>
		</part>		
	</presentation>
	<presentation id="dtd">
		<title short="DTD">Document Type Definition (DTD)</title>
		<date>2013-09-11</date>
		<toc class="abstract">The XML specification defines a format for structured data (XML documents) and a grammar-based constraint language for these (DTD). In SGML-based systems, DTDs were often very complex and feature-rich constructs, which controlled a lot of the processing of SGML documents. XML greatly simplified DTDs, and de-facto usage of DTDs today simplified them even more. In many systems today, DTDs are not used at all or generated from sample documents. In this lecture, it is argued that DTDs (or schemas, to be more general) should be taken seriously in any non-trivial XML application, because they are a representation of the underlying (and often underspecified) data model of the application.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Schema Languages</title>
			<slide>
				<title>XML Validation</title>
				<ul>
					<li>XML knows two <q>types</q> of documents, <em>well-formed</em> and <em>valid</em></li>
					<li><em>well-formed</em> documents satisfy all basic constraints of the XML specification</li>
					<ul>
						<li>they can be parsed according to the XML grammar</li>
						<li>they satisfy the additional constraints (e.g., start and end tags match)</li>
						<li>together, this means they can be translated into a <link href="xmltree">tree</link></li>
						<li>this tree then can be processed with XML tools (<link href="sax">SAX</link>, <link href="dom">DOM</link>, <link href="xslt-1">XSLT</link>, …)</li>
					</ul>
					<li><em>valid</em> documents must satisfy the constraints of a DTD</li>
					<ul>
						<li>a document must be well-formed before it can be validated</li>
						<li>all elements and attributes have been defined</li>
						<li>elements and attributes are used according to their definition</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Validation and Applications</title>
				<img src="valid-documents.png" style="width : 90% ; margin : 4% ; "/>
			</slide>
			<slide>
				<title>Non-XML, Well-Formed, and Valid</title>
				<listing src="non.xml" line="3-9"/>
				<listing src="address-invalid.xml" line="3-9"/>
				<listing src="address-valid.xml" line="3-9"/>
			</slide>
			<slide>
				<title>DTD Example</title>
				<listing src="address-valid.xml" line="1-2"/>
				<listing src="address.dtd"/>
				<ul>
					<li>The DTD defines constraints on element and attribute usage</li>
					<li>The DTD does only in part constrain textual contents</li>
				</ul>
			</slide>
			<slide>
				<title>XML Schema Languages</title>
				<ul>
					<li>DTDs are part of XML itself</li>
					<ul>
						<li>XML specifies the document format <u>and</u> one schema language</li>
						<li>DTD support is provided by most XML processors (<a href="http://www.w3.org/TR/REC-xml/#proc-types" title="XML specification">validating processors</a>)</li>
					</ul>
					<li>Other schema languages are available</li>
					<ul>
						<li><link href="xsd-1">XSD</link> as the W3C's recommendation</li>
						<li><a href="http://www.schematron.com/">Schematron</a> as a rule-based alternative</li>
						<li>various other research projects and products</li>
					</ul>
					<li>Choosing appropriate schema language(s) is important</li>
					<ul>
						<li>we look at DTDs because they are part of XML itself</li>
						<li>we look at XSD because it is widely used</li>
						<li>Schematron is interesting because it is simple and powerful</li>
						<li>you may even invent your own schema language (a.k.a. <em>meta-programming</em>)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>DTD Basics</title>
			<slide>
				<title>XML is <q>SGML light</q></title>
				<ul>
					<li>XML is a subset of SGML</li>
					<ul>
						<li>XML documents have been greatly simplified</li>
						<li>XML DTDs have retained some of SGML's peculiarities</li>
					</ul>
					<li>DTD design should be left to XML experts</li>
					<ul>
						<li>simple DTDs (for prototypes) are easy to define (or generate)</li>
						<li>serious DTDs for complex data models are hard to define</li>
					</ul>
					<li>XML is a useful tool for experiments and prototypes</li>
					<ul>
						<li>basic knowledge of DTDs is required</li>
						<li>serious XML schemas often use <link href="xsd-1">XSD</link> anyway</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Associating Documents and DTDs</title>
				<ul>
					<li>A DTD is a schema for a set of documents</li>
					<ul>
						<li>there may be just one document for a DTD, there may be billions (HTML)</li>
						<li>in most cases, DTDs are managed as a separate resource</li>
					</ul>
					<li>The <a href="http://www.w3.org/TR/xml#sec-prolog-dtd"><em>Document Type Declaration</em></a> <q>contains or points to markup declarations that provide a grammar for a class of documents</q></li>
					<ul>
						<li>the part which is contained is called <em>Internal Subset</em></li>
						<li>the part which is pointed to is called <em>External Subset</em></li>
						<li>internal and external subset together are the <em>Document Type Definition (DTD)</em></li>
					</ul>
					<li>External subsets are identified by <em>Public</em> and <em>System Identifiers</em></li>
					<ul>
						<li><em>public identifiers</em> use a special notation</li>
						<li><em>system identifiers</em> are URIs (relative or absolute)</li>
						<li>applications use (i.e., know or retrieve) the DTD for validation</li>
					</ul>
				</ul>
				<listing src="address-valid.xml" line="1-2"/>
			</slide>
			<part>
				<title>DTD Syntax</title>
				<slide>
					<title>DTDs are not XML Documents</title>
					<ul>
						<li>DTDs use a special syntax</li>
						<ul>
							<li>somewhat ironic when everything else is XMLized</li>
							<li>DTDs cannot be processed with standard XML tools</li>
							<li>more compact than XML syntax</li>
						</ul>
						<li>Definition of elements and attribute lists</li>
						<ul>
							<li>elements are defined by the content they allow</li>
							<li>attribute lists are sets of allowed attributes on elements</li>
						</ul>
					</ul>
					<listing src="address.dtd"/>
				</slide>
				<slide>
					<title>Syntax Rules</title>
					<ul>
						<li>There is no container containing the whole DTD</li>
						<ul>
							<li><code>&lt;!ELEMENT example EMPTY></code> thus is a complete DTD</li>
						</ul>
						<li>Definitions (officially called <em>declarations</em>) use <code>&lt;!… ></code> syntax</li>
						<ul>
							<li><code>ELEMENT</code> is used to <link href="dtd-element">define an element</link></li>
							<li><code>ATTLIST</code> is used to <link href="dtd-attlist">define an attribute list</link></li>
							<li><code>ENTITY</code> is used to <link href="dtd-entity">define an entity</link></li>
						</ul>
						<li>The document element is not marked explicitly</li>
						<ul>
							<li>but it must be declared in the document type declaration</li>
							<li>this means the document element is established by the document, not by the DTD</li>
						</ul>
					</ul>
				<listing src="address-valid.xml" line="1-3"/>
				</slide>
			</part>
			<part id="dtd-element">
				<title>Defining Elements</title>
				<slide id="element-only-declaration">
					<title>Element Only Content</title>
					<ul>
						<li>Element content is defined by a grammar for the children</li>
						<ul>
							<li>sequences are indicated with a comma: <q><code>,</code></q></li>
							<li>choices are indicated with a vertical bar: <q><code>|</code></q></li>
							<li>optional parts are indicated with a question mark: <q><code>?</code></q></li>
							<li>repeatable parts are indicated with a plus: <q><code>+</code></q></li>
							<li>optional and repeatable parts are indicated with a asterisk: <q><code>*</code></q></li>
							<li>parentheses can be used for grouping and nesting</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="1064-1074"/>
				</slide>
				<slide id="mixed-content-declaration">
					<title>Mixed Content</title>
					<ul>
						<li><link href="mixed-content"/> allows text content and elements to be mixed</li>
						<ul>
							<li><link href="whitespace"/> characters are allowed in <link href="element-only-declaration"/> (this must not be declared)</li>
							<li>for non-whitespace characters, character data must be allowed explicitly</li>
						</ul>
						<li>The allowed child elements may be constrained, but not their order or their number of occurrences</li>
						<li>Mixed Content always is defined as <code>&lt;!ELEMENT x (#PCDATA | a | b | …)* ></code></li>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="568-568"/>
					<ul>
						<li><em>Character only</em> content is a special case of mixed content</li>
						<ul>
							<li>the element may only contain characters (no other elements)</li>
							<li>the repetition is not necessary because there is no choice</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="355-355"/>
				</slide>
				<slide>
					<title>Empty Content</title>
					<ul>
						<li>Empty elements can be useful</li>
						<ul>
							<li>they may contain all information in attributes</li>
							<li>their presence may carry semantics without the need for additional information</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="833-848"/>
				</slide>
			</part>
			<part id="dtd-attlist">
				<title>Defining Attribute Lists</title>
				<slide>
					<title>Attributes belong to Elements</title>
					<ul>
						<li>Attributes are specified in an element's <em>Attribute List</em></li>
						<ul>
							<li>an element definition may have any number of attributes associated with it</li>
							<li>attributes may occur at most once on an element</li>
						</ul>
						<li>Attributes definitions have a <em>name</em>, a <em>type</em>, and a <em>default declaration</em></li>
						<ul>
							<li>the attribute appears according to the default declaration</li>
							<li>if the attribute is present, its value must conform to the type</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="794-801"/>
				</slide>
				<slide id="dtd-attr-type">
					<title>Attribute Types</title>
					<ul>
						<li>Attribute values can be constrained (which is not possible for element content)</li>
						<ul>
							<li><code>CDATA</code> means any character string (but no markup)</li>
							<li>enumerated types list allowed values: <code>(data|ref|object)</code> (list of XML names)</li>
							<li><code>ID</code> for identifying elements (part of <code><link href="ididref"/></code>)</li>
							<li><code>IDREF</code> for referencing identified elements (part of <code><link href="ididref"/></code>)</li>
						</ul>
						<li>Application-oriented attribute types are often <q>simulated</q></li>
						<ul>
							<li>using <link href="param-entity"/>, modeling information can be preserved</li>
						</ul>
					</ul>
					<listing src="xhtml1-transitional.dtd" line="894-894"/>
					<listing src="xhtml1-transitional.dtd" line="52-53"/>
					<ul>
						<li>The default declaration specifies the attribute's presence</li>
						<ul>
							<li><code>#REQUIRED</code> means the attribute has to be specified (on every element)</li>
							<li><code>#IMPLIED</code> marks an optional attribute (the parser may imply a value)</li>
							<li><code>"…"</code> specifies a default value (and the attribute is optional)</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Advanced DTDs</title>
			<part id="ididref">
				<title>ID/IDREF</title>
				<slide>
					<title>References in Documents</title>
					<ul>
						<li>Without Validation, there are no IDs</li>
						<ul>
							<li><code>ID</code> is an <link href="dtd-attr-type">attribute type</link> declared in the DTD</li>
							<li><link href="xml:id"><code>xml:id</code></link> is an attempt to support schema-independent IDs</li>
						</ul>
						<li>IDs are used to assign identities to elements</li>
						<ul>
							<li>the XML processor reports duplicate IDs as errors (<a href="http://www.w3.org/TR/xml/#id">part of validation</a>)</li>
						</ul>
						<li>IDREFs are used to reference existing IDs</li>
						<ul>
							<li>the XML processor reports references to non-existing IDs as errors (<a href="http://www.w3.org/TR/xml/#idref">part of validation</a>)</li>
						</ul>
						<li>IDs must be XML Names (in particular, they may not start with a number)</li>
					</ul>
				</slide>
				<slide>
					<title>ID/IDREF in a Document</title>
					<listing src="section.xml" line="3-18"/>
					<listing src="section.dtd" line="2-12"/>
				</slide>
				<slide>
					<title>References within the Tree</title>
					<img src="section.png" style="width : 90% ; margin : 4% ; "/>
				</slide>
				<slide>
					<title>Formatting Example</title>
					<p>Hotspot can generate links to sections such as the section about <link href="ididref"/>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>
					<pre><![CDATA[<p>Hotspot can generate links to sections such as the section about <link href="ididref"/>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>]]></pre>
					<p>After running Hotspot, the following HTML is generated:</p>
					<pre><![CDATA[<p>Hotspot can generate links to sections such as the section about <a href="#ididref">ID/IDREF</a>, this link is then translated into the appropriate HTML code, meaning a link with the target being a fragment identifier to the slide number.</p>]]></pre>
				</slide>
				<slide>
					<title>ID/IDREF Semantics</title>
					<ul>
						<li>Rooted in the document world</li>
						<ul>
							<li>all parts are assembled before processing</li>
							<li>names are symbolic and assigned as required</li>
							<li>mixed syntax and semantics</li>
						</ul>
						<li>Good idea, but many shortcomings</li>
						<ul>
							<li>constraints apply to one document only</li>
							<li>IDs and IDREFs are global instead of scoped</li>
							<li>identifiers should be allowed to use any type</li>
							<li>identifier processing should be type-specific (2 &#x225F; 02)</li>
						</ul>
						<li>Applications must know how to process ID/IDREF</li>
						<ul>
							<li>for HTML export, links can be generated</li>
							<li>for databases, keys should be used</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="dtd-entity">
				<title>Entities</title>
				<slide>
					<title>General Entities</title>
					<ul>
						<li>XML's core concept of physical data structures</li>
						<ul>
							<li>an entity is a named unit of data which can be referenced</li>
							<li>within documents, it is referenced by the markup <code>&amp;entity-name;</code></li>
						</ul>
						<li>Entities can be used to name and reuse document content</li>
					</ul>
					<listing src="xhtml-lat1.ent" line="135-142"/>
					<ul>
						<li><em>Character References</em> look like entities: <code>&amp;#9786;</code> or <code>&amp;#x263A;</code> = &#x263A;</li>
						<ul>
							<li>they can be used to represent any Unicode character, they are processed as single characters</li>
						</ul>
					</ul>
				</slide>
				<slide id="param-entity">
					<title>Parameter Entities</title>
					<ul>
						<li>Parameter entities are parsed entities for use within the DTD</li>
						<ul>
							<li>a parameter entity must be specifically declared as such</li>
							<li>within DTDs, it is referenced by the markup <code>%entity-name;</code></li>
							<li>outside of DTDs, parameter entities cannot be used</li>
						</ul>
						<li>As general entities, parameter entities are meant for reuse</li>
						<ul>
							<li>in a DTD, reuse is mostly about reusing structures</li>
							<li>parameter entities are DTDs <q>duct tape</q>, not elegant, but effective</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XHTML Parameter Entities (Attributes)</title>
					<listing src="xhtml1-transitional.dtd" line="433-437"/>
					<listing src="xhtml1-transitional.dtd" line="188-188"/>
					<listing src="xhtml1-transitional.dtd" line="133-138"/>
					<listing src="xhtml1-transitional.dtd" line="145-149"/>
					<listing src="xhtml1-transitional.dtd" line="55-56"/>
					<listing src="xhtml1-transitional.dtd" line="193-193"/>
				</slide>
				<slide>
					<title>XHTML Parameter Entities (Content)</title>
					<listing src="xhtml1-transitional.dtd" line="433-437"/>
					<listing src="xhtml1-transitional.dtd" line="230-230"/>
					<listing src="xhtml1-transitional.dtd" line="227-227"/>
					<listing src="xhtml1-transitional.dtd" line="203-204"/>
					<listing src="xhtml1-transitional.dtd" line="200-201"/>
					<listing src="xhtml1-transitional.dtd" line="197-198"/>
					<listing src="xhtml1-transitional.dtd" line="222-222"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>DTD for XML Schemas</title>
				<ul>
					<li>XML documents are processed by applications</li>
					<li>Applications have assumptions about XML documents</li>
					<li>DTDs allow to formalize some of these constraints</li>
					<li>Part of the constraint checking must still be programmed</li>
				</ul>
			</slide>
			<slide>
				<title>Modeling DTDs</title>
				<ul>
					<li>Data models can be mapped to many different DTDs</li>
					<li>What is a good DTD? What is a bad DTD?</li>
					<li>How does the DTD affect further processing?</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xpath">
		<title short="XPath">XML Path Language (XPath)</title>
		<date>2013-09-16</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xpath" title="W3C XPath 1.0 Specification">XPath&#160;1.0&#160;Spec</a>&#160;· <a href="xpath-chapter.pdf">XPath Chapter</a></toc>
		<toc class="abstract">XML structures data into a rather small number of different constructs, most notably elements and attributes. The <em>XML Path Language (XPath)</em> defines a way how to select parts of XML documents, so that they can be used for further processing. XPath's primary use is in <em>XSL Transformations (XSLT)</em>, but other XML technologies use it as well, e.g. XSD. XPath is a very compact language with a syntax that resembles path expressions well-known from file systems. These path expressions, however, are generalized and therefore much more powerful than the rather simple path expressions in file systems. Because of its use in different XML technologies, XPath is one of the most important XML core technologies.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Why XPath?</title>
			<slide>
				<title>Selecting Parts of XML Documents</title>
				<ul>
					<li>XML is a syntax for trees</li>
					<ul>
						<li>it defines a way for how trees can be exchanged</li>
					</ul>
					<li>XML technologies should provide support for working with trees</li>
					<ul>
						<li>when receiving trees, access to the tree should be easy (DOM)</li>
						<li>validating trees should be easy (<link href="xsd-1">XSD</link>)</li>
						<li>mapping trees should be easy (<link href="xslt-1">XSLT</link>)</li>
						<li>querying tree collections should be easy (<link href="xquery-1">XQuery</link>)</li>
						<li>XPath is what regular expressions are for text-based information</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Making Selection Reusable</title>
				<ul>
					<li>Different XML technologies need selection</li>
					<ul>
						<li><link href="xslt-1">XSLT</link> needs it for selecting parts and manipulating them</li>
						<li><link href="xsd-1">XSD</link> needs it for applying identity constraints</li>
						<li>DOM needs it for extracting parts from an XML tree</li>
						<li>XQuery needs it for writing XML-oriented queries</li>
					</ul>
					<li>XPath was created to be reusable</li>
					<ul>
						<li>XML experts should only learn one selection language</li>
						<li>this knowledge can be reused when learning new technologies</li>
						<li>implementations can reuse code libraries</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>How XPath Evolved</title>
				<ul>
					<li>XSL was designed as the new XML stylesheet language</li>
					<ol>
						<li><link href="xslt-1">XSL Transformations (XSLT)</link> transform the input document</li>
						<li><em>XSL Formatting Objects (XSL-FO)</em> is what they will transform it to</li>
					</ol>
					<li>XSLT was designed to work on arbitrary XML input documents</li>
					<ul>
						<li>started as a part of XSL (<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">WD-xsl-19981216</a> → <a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a>)</li>
						<li>for selecting parts of the transformation input, a selection mechanism had to be provided</li>
					</ul>
					<li>XPath was turned into a standalone specification</li>
					<ul>
						<li>started as a part of XSLT (<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a> → <a href="http://www.w3.org/1999/07/WD-xslt-19990709">WD-xslt-19990709</a>)</li>
						<li>reused in a number of other W3C specifications (XSD, DOM)</li>
					<li>Complete overhaul for XSLT 2.0 and XQuery</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xpath20/">XPath 2.0</a> as the core language</li>
						<li>a much larger set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
						<li>the underlying <a href="http://www.w3.org/TR/xpath-datamodel/">data model</a> which describes the foundation</li>
					</ul>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>How XPath Works</title>
			<part id="xpath-tree">
				<title>The XPath Tree Model</title>
				<slide>
					<title>Starting from the Infoset</title>
					<ul>
						<li>XPath operates on an abstract data model</li>
						<ul>
							<li>a tree derived from the <link href="infoset"/></li>
							<li>a simplification (another one!) of the underlying XML</li>
						</ul>
						<li>The Infoset is turned into an <em>XPath node tree</em></li>
						<ul>
							<li>11 infoset item types → 7 XPath node tree node types</li>
							<li>character items are merged into text nodes</li>
							<li>namespace declarations are no longer visible as attributes</li>
						</ul>
					</ul>
				</slide>
				<slide id="not-xpath">
					<title>What is <u>Not</u> in the XPath Tree</title>
					<ul>
						<li>The same things which are <link href="not-infoset">not in the Infoset</link></li>
						<ul>
							<li>the order of attributes in a start tag</li>
							<li>the types of quotes around attribute values</li>
							<li>character references and entities (<code>&amp;#xFC;</code>/<code>&amp;uuml;</code> → <code>ü</code>)</li>
						</ul>
						<li>And some more …</li>
						<ul>
							<li>namespace declarations are no longer visible as attributes</li>
							<li>notations and unexpanded entity references</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part>
				<title>XPath Evaluation</title>
				<slide>
					<title>Tree In / Selection Out</title>
					<ul>
						<li>XPath evaluates an expression based on a tree</li>
						<li>Where the tree comes from is out of XPath's scope</li>
						<li>The result of the evaluation is a selection</li>
						<ul>
							<li><code>//img[not(@alt)]</code> → select all images which have no <code>alt</code> attribute</li>
							<li><code>count(//img)</code> → return the number of images</li>
							<li><code>/descendant::img[3]/@src</code> → return the third image's <code>src</code> URI</li>
							<li><code>starts-with(/html/@lang, 'en')</code> → test whether the document's language is english</li>
						</ul>
						<li>Syntax errors may occur</li>
						</ul>
				</slide>
			</part>
		</part>
		<part>
			<title short="Location Paths">XPath Location Paths</title>
			<slide>
				<title>Location Path Structure</title>
				<ul>
					<li>Each location path consists of <em>Location Steps</em></li>
					<ul>
						<li>location steps are separated by <q><code>/</code></q>, like path names in file systems</li>
					</ul>
					<li>Similarities between XPath location paths and file systems</li>
					<ol>
						<li>nodes in the <link href="xpath-tree">XPath tree</link> have different types</li>
						<li>the <link href="xpath-nodetest">type and number of nodes selected by one step</link></li>
						<li>the <link href="xpath-axes">direction in which each step moves</link></li>
						<li>additional <link href="xpath-predicates">filters for selecting specific nodes</link></li>
					</ol>
					<li>Differences between XPath location paths and file systems</li>
					<ol>
						<li>XPaths may return <link href="xpath-expressions">other data types than nodes</link></li>
						<li>XPath provides a <link href="xpath-functions">built-in function library</link></li>
					</ol>
				</ul>
			</slide>
			<part>
				<title short="Node Tests">XPath Node Tests</title>
				<slide>
					<title>File System vs. XPath Paths</title>
					<table style="margin : 5% ; " width="85%">
						<tr>
							<th>File System Path:</th>
							<td align="center"><code>/</code></td>
							<td align="center"><code>usr</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>local</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>apache</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>bin</code></td>
							<td align="center"><code>/</code></td>
						</tr>
						<tr>
							<th># Selected Nodes:</th>
							<td align="center">1</td>
							<td align="center">→ 1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">1</td>
						</tr>
					</table>
					<table style="margin : 5% ; " width="85%">
						<tr>
							<th>XPath:</th>
							<td align="center"><code>/</code></td>
							<td align="center"><code>html</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>body</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>table</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>thead</code></td>
							<td align="center"><code>/</code></td>
							<td align="center"><code>tr</code></td>
						</tr>
						<tr>
							<th># Selected Nodes:</th>
							<td align="center">1</td>
							<td align="center">→ 1</td>
							<td align="center">→</td>
							<td align="center">1</td>
							<td align="center">→</td>
							<td align="center">6</td>
							<td align="center">→</td>
							<td align="center">4</td>
							<td align="center">→</td>
							<td align="center">12</td>
						</tr>
					</table>
				</slide>
				<slide id="xpath-nodetest">
					<title>Tests for Nodes</title>
					<ul>
						<li>Name tests</li>
						<ul>
							<li>testing for a particular name (elements/attributes): <code>/html/head/title</code></li>
							<li>wildcards (testing for any name): <code>/html/head/*</code></li>
						</ul>
						<li>Node type tests</li>
						<ul>
							<li>text nodes: <code>text()</code></li>
							<li>comment nodes: <code>comment()</code></li>
							<li>any nodes: <code>node()</code></li>
						</ul>
						<li>Processing instruction tests</li>
						<ul>
							<li>any PI: <code>processing-instruction()</code></li>
							<li>specific PI: <code>processing-instruction("xml-stylesheet")</code></li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xpath-axes">
				<title short="Axes">XPath Axes</title>
				<slide>
					<title>Where Do You Want to Go Today?</title>
					<ul>
						<li>File system paths are one direction only</li>
						<ul>
							<li>always one level down in the file system hierarchy</li>
							<li><code>.</code> and <code>..</code> are clever directory shortcuts</li>
							<li>other directions supported by tools (e.g., <code>find</code>)</li>
						</ul>
						<li>XPath allows steps is different directions</li>
						<ul>
							<li>the default direction is <code>child</code></li>
							<li>other directions are explicitly specified: <code>descendant::a</code></li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Axis Peculiarities</title>
					<ul>
						<li>Attributes and Namespaces are <u>not</u> the children of elements, but …</li>
						<li>… elements are their attributes' parent!</li>
						<ul>
							<li>very counter-intuitive</li>
							<li>very convenient</li>
						</ul>
						<li>Attributes and Namespaces are always leaves in the node tree</li>
						<li>Attribute nodes <u>have</u> the attribute value as their value</li>
						<li>Namespace nodes <u>have</u> the namespace name (i.e., a URI) as their value</li>
						<li>Namespace nodes exist because of namespace declarations</li>
						<ul>
							<li>in the XPath node tree, only the namespace nodes are visible</li>
							<li>the namespace declaration attributes (<code>xmlns</code>) are invisible</li>
							<li>one namespace declaration potentially creates many namespace nodes</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Axes</title>
					<img style="height : 75% ; margin : 2% ; " src="xpath-axes.png" title="XPath Axes"/>
				</slide>
				<slide>
					<title>Putting it all Together</title>
					<ul>
						<li>XPath location paths use a simple syntax</li>
						<ul>
							<li>sequence of location steps, separated by <q><code>/</code></q></li>
						</ul>
						<li>Each location step uses a simple structure (<code>preceding::p[@class="warning"]</code>)</li>
						<ol>
							<li>an axis followed by <q><code>::</code></q> (no axis uses the default axis <code>child</code>)</li>
							<li>a <link href="xpath-nodetest">node test</link></li>
							<li><em>0-n</em> <link href="xpath-predicates"/> enclosed in <q><code>[]</code></q></li>
						</ol>
						<li>Location paths can be abbreviated</li>
						<ul>
							<li><code>child::</code> can be omitted (default axis)</li>
							<li><code>attribute::</code> can be written as <q><code>@</code></q></li>
							<li><q><code>.</code></q> is an abbreviation for <code>self::node()</code></li>
							<li><q><code>..</code></q> is an abbreviation for <code>parent::node()</code></li>
							<li><q><code>//</code></q> is an abbreviation for <code>/descendant-or-self::node()/</code></li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xpath-predicates">
				<title>Predicates</title>
				<slide>
					<title>Location Step Filters</title>
					<ul>
						<li>Predicates are filters for each location step</li>
						<ul>
							<li>there can be any number of filters (<em>0-n</em>)</li>
							<li>each filter is applied to each selected node individually</li>
						</ul>
						<li>Each predicate is an XPath and evaluated as a boolean</li>					
						<ul>
							<li>the context of this evaluation is the node for which the filter is evaluated</li>
							<li>if the result is a number, it is compared with the <code>position()</code> function (<code>/descendant::a[5]</code>)</li>
						</ul>
						<li>Predicates always reduce the set of selected nodes</li>
						<ul>
							<li>as corner cases, the set of selected nodes does not change or is empty</li>
							<li>predicates are used in the majority of non-trivial XPath location paths</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Location Path Processing</title>
					<ul>
						<li>Location paths are processed in a very simple way</li>
						<ol>
							<li>start with a given context</li>
							<li>for each location step, repeat the following steps:</li>
							<li>based on the context and the axis, select the nodes on this axis</li>
							<li>reduce this selection to the nodes identified by the node test</li>
							<li>sequentially apply all filters to each of these nodes</li>
							<li>take the remaining node set as the context for the next location step</li>
						</ol>
					</ul>
				</slide>
			</part>
		</part>
		<part id="xpath-expressions">
			<title>XPath Expressions</title>
			<slide>
				<title>Beyond Location Paths</title>
				<ul>
					<li>XPath is a full expression language</li>
					<ul>
						<li>any evaluated expression in XSLT is an XPath</li>
						<li>XPath must be able to calculate operate on non-XML data types</li>
					</ul>
					<li>XPath uses a very simple data model</li>
					<ol>
						<li>node sets: <code>//img[not(@alt)]</code></li>
						<li>number: <code>count(//img)</code></li>
						<li>string: <code>/descendant::img[3]/@src</code></li>
						<li>boolean: <code>starts-with(/html/@lang, 'en')</code></li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>XPath Usages</title>
				<ul>
					<li>XPath is used in different technologies</li>
					<ul>
						<li>XSLT uses XPath as its expression language</li>
						<li>XSD uses XPath for selecting identity constraint nodes</li>
						<li>DOM uses XPath as a way to select DOM nodes</li>
					</ul>
					<li>Depending on the environment, expression must yield certain results</li>
					<ul>
						<li>for conditionals, a boolean must be returned</li>
						<li>iterations (in XSLT) only loop over nodes</li>
						<li>when printing out text, a string must be produced</li>
					</ul>
					<li>XPath has built-in rules for casting types</li>
					<ul>
						<li>node set → boolean: empty is false, non-empty is true</li>
						<li>node → string: take the <em>string value</em> (i.e., concatenate all text node descendants)</li>
						<li>string → number: interpret as decimal notation (otherwise return <q><code>NaN</code></q>)</li>
						<li>XPaths often return surprising results (<code>//a[starts-with(@href, https)]</code>)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="xpath-functions">
			<title>XPath Functions</title>
			<slide>
				<title>Function Library</title>
				<ul>
					<li>XPath has a small library of built-in functions</li>
					<ul>
						<li>useful for basic XPath-level functions</li>
						<li>other specs are allowed to extend it (XSLT does it)</li>
					</ul>
					<li>XPath functions return results of various data types</li>
					<ul>
						<li>boolean: <code>boolean, contains, false, lang, not, starts-with, true</code></li>
						<li>number: <code>ceiling, count, floor, last, number, position, round, string-length, sum</code></li>
						<li>string: <code>concat, local-name, name, namespace-uri, normalize-space, string, substring, substring-after, substring-before, translate</code></li>
						<li>node set: <code>id</code></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Using Functions</title>
				<ul>
					<li>Functions and location paths are orthogonal</li>
					<ul>
						<li>each construct may be based on the other</li>
						<li>it is possible to nest them arbitrarily</li>
						<li>predicates often contain functions</li>
						<pre>//a[substring(@href,string-length(@href)-2)='pdf']</pre>
					</ul>
					<li>XPaths can become powerful and complex</li>
					<ul>
						<li>writing some code or thinking about an XPath?</li>
						<li>XPaths are more declarative</li>
						<li>they may be more robust against changes in the XML schema</li>
						<li>they can be optimized by a smart XPath implementation</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Limitations of XPath</title>
			<slide>
				<title>XPath Selects</title>
				<ul>
					<li>Query languages select and recombine</li>
					<ol>
						<li>look up all addresses by zip code</li>
						<li>for each zip code, count the number of addresses</li>
					</ol>
					<li>XSLT fills in the missing parts (as a programming language)</li>
					<ul>
						<li>XSLT can construct XML and re-apply XPath</li>
					</ul>
					<li>XQuery fills in the missing parts (query-wise)</li>
					<ul>
						<li>80% of XQuery are XPath (in version 2.0, though)</li>
						<li>the remaining 20% are bindings, constructors, and glue</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XPath is Important</title>
				<ul>
					<li>XPath is a basic tool of the XML toolbox</li>
					<li>XPath is reused in various XML technologies</li>
					<li>XPath selects parts of an XML document</li>
					<li>XPath can do more general things by using expressions</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xpath20">
		<title short="XPath 2.0">XML Path Language (XPath) 2.0</title>
		<date>2013-09-18</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xpath20" title="W3C XPath 2.0 Specification">XPath&#160;2.0&#160;Spec</a></toc>
		<toc class="abstract">The <em>XML Path Language (XPath)</em> is one of the most useful and frequently used languages in the area of XML technologies. In its version 1.0, it is used in technologies such as XSLT, XSD, DOM, and XML Tools. With <em>XPath 2.0</em>, the language has been greatly extended, the new version of XPath is the foundation for XSLT 2.0 and XQuery. XPath 2.0 provides support for regular expression matching, typed expressions, and contains language constructs for conditional and repeated evaluation.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>Why XPath?</title>
			<slide>
				<title>Selecting Parts of XML Documents</title>
				<ul>
					<li>XML is a syntax for trees</li>
					<ul>
						<li>it defines a way for how trees can be exchanged</li>
					</ul>
					<li>XML technologies should provide support for working with trees</li>
					<ul>
						<li>when receiving trees, access to the tree should be easy (DOM)</li>
						<li>validating trees should be easy (<link href="xsd-1">XSD</link>)</li>
						<li>mapping trees should be easy (<link href="xslt-1">XSLT</link>)</li>
						<li>querying tree collections should be easy (<link href="xquery-1">XQuery</link>)</li>
						<li>XPath is what regular expressions for text-based information</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Making Selection Reusable</title>
				<ul>
					<li>Different XML technologies need selection</li>
					<ul>
						<li><link href="xslt-1">XSLT</link> needs it for selecting parts and manipulating them</li>
						<li><link href="xsd-1">XSD</link> needs it for applying identity constraints</li>
						<li>DOM needs it for extracting parts from an XML tree</li>
						<li>XQuery needs it for writing XML-oriented queries</li>
					</ul>
					<li>XPath was created to be reusable</li>
					<ul>
						<li>XML experts should only learn one selection language</li>
						<li>this knowledge can be reused when learning new technologies</li>
						<li>implementations can reuse code libraries</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>How XPath Evolved</title>
				<ul>
					<li>XSL was designed as the new XML stylesheet language</li>
					<ol>
						<li><em>XSL Transformations (XSLT)</em> transform the input document</li>
						<li><em>XSL Formatting Objects (XSL-FO)</em> is what they will transform it to</li>
					</ol>
					<li>XSLT was designed to work on arbitrary XML input documents</li>
					<ul>
						<li>started as a part of XSL (<a href="http://www.w3.org/TR/1998/WD-xsl-19981216">WD-xsl-19981216</a> → <a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a>)</li>
						<li>for selecting parts of the transformation input, a selection mechanism had to be provided</li>
					</ul>
					<li>XPath was turned into a standalone specification</li>
					<ul>
						<li>started as a part of XSLT (<a href="http://www.w3.org/TR/1999/WD-xslt-19990421">WD-xslt-19990421</a> → <a href="http://www.w3.org/1999/07/WD-xslt-19990709">WD-xslt-19990709</a>)</li>
						<li>reused in a number of other W3C specifications (XSD, DOM)</li>
					</ul>
					<li>Complete overhaul for XSLT 2.0 and XQuery</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xpath20/">XPath 2.0</a> as the core language</li>
						<li>a much larger set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
						<li>the underlying <a href="http://www.w3.org/TR/xpath-datamodel/">data model</a> which describes the foundation</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>How XPath Works</title>
			<part>
				<title>The XPath Tree Model</title>
				<slide>
					<title>Starting from the Infoset</title>
					<ul>
						<li>XPath operates on an <link href="xpath-tree">abstract data model</link></li>
						<ul>
							<li>a tree derived from the <link href="infoset"/></li>
							<li>a simplification (another one!) of the underlying XML</li>
						</ul>
						<li>The Infoset is turned into an <em>XPath node tree</em></li>
						<ul>
							<li>11 infoset item types → 7 XPath node tree node types</li>
							<li>character items are merged into text nodes</li>
							<li>namespace declarations are no longer visible as attributes</li>
						</ul>
					</ul>
				</slide>
				<slide id="not-xpath">
					<title>What is <u>Not</u> in the XPath Tree</title>
					<ul>
						<li>The same things which are <link href="not-infoset">not in the Infoset</link></li>
						<ul>
							<li>the order of attributes in a start tag</li>
							<li>the types of quotes around attribute values</li>
							<li>character references and entities (<code>&amp;#xFC;</code>/<code>&amp;uuml;</code> → <code>ü</code>)</li>
						</ul>
						<li>And some more …</li>
						<ul>
							<li>namespace declarations are no longer visible as attributes</li>
							<li>notations and unexpanded entity references</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part>
				<title>XPath Evaluation</title>
				<slide>
					<title>Tree In / Selection Out</title>
					<ul>
						<li>XPath evaluates an expression based on a tree</li>
						<li>Where the tree comes from is out of XPath's scope</li>
						<li>The result of the evaluation is a selection</li>
						<ul>
							<li><code>//img[not(@alt)]</code> → select all images which have no <code>alt</code> attribute</li>
							<li><code>count(//img)</code> → return the number of images</li>
							<li><code>/descendant::img[3]/@src</code> → return the third image's <code>src</code> URI</li>
							<li><code>starts-with(/html/@lang, 'en')</code> → test whether the document's language is english</li>
						</ul>
						<li>Syntax errors may occur</li>
						</ul>
				</slide>
			</part>
		</part>
		<part>
			<title short="XPath 1.0">XPath 1.0 Revisited</title>
			<slide>
				<title>Source Document</title>
				<listing src="xlinked-class.xml" line="81-98" title="Web-Based Publishing Class – Spring 2007"/>
			</slide>
			<slide>
				<title>XPath Expressions</title>
				<ul>
					<li>XPaths can be location paths</li>
					<pre>//ul/li</pre>
					<li>XPaths can use functions</li>
					<pre>id('dret')</pre>
					<li>XPaths can be expressions yielding atomic values</li>
					<pre>substring-before(id('dret'), ' ')</pre>
					<li>XPaths can combine all of the above</li>
					<pre>count(//ul/li[starts-with(substring-after(., ' '), 'W')])</pre>
				</ul>
			</slide>
			<slide>
				<title>Axes</title>
				<img style="width : 86% ; margin : 4% ; " src="xpath-axes.png"/>
			</slide>
		</part>
		<part>
			<title>Ease of Use</title>
			<slide>
				<title>Easier to Understand</title>
				<ul>
					<li>XPath 2.0 provides better ways to write XPaths</li>
					<ul>
						<li>some constructs allow better ways of writing XPaths</li>
						<li>some constructs allow things previously impossible in XPath</li>
					</ul>
					<li>XPath usually is embedded in another language (XQuery, XSLT)</li>
					<ul>
						<li>even in XSLT 1.0, there was always a trade-off between XPath and XSLT</li>
						<li>with XPath 2.0, even more powerful XPaths can be implemented</li>
					</ul>
					<li>Finding a good balance between XPath and the host language is an art</li>
					<ul>
						<li>very complex XPaths can become almost undecipherable</li>
						<li>there is no final answer, coding styles vary based on language preference</li>
					</ul>
				</ul>
				<pre>&lt;listing src="xlinked-class.xml" line="81-98"/></pre>
				<pre>string-join(tokenize( if ( exists(@encoding) ) then unparsed-text($fileuri, @encoding) else unparsed-text($fileuri), '\r?\n')[(position() ge number(tokenize(current()/@line, '\-')[1])) and (position() le number(tokenize(current()/@line, '\-')[2]))], '&amp;#xa;')</pre>
			</slide>
			<part id="xpath20-conditional">
				<title>Conditional Expressions</title>
				<slide>
					<title>Control Flow in XPath</title>
					<ul>
						<li>XPath 1.0 expressions <q>control flow</q> is based on predicates</li>
						<ul>
							<li>the results of location path steps are filtered by predicates</li>
							<li>this can be used to <q>emulate</q> control flow</li>
							<li>this technique is limited because it can only be applied to nodes</li>
						</ul>
						<li>XPath 2.0 introduces conditional expressions</li>
						<ul>
							<li>a condition is given which is interpreted as a boolean</li>
							<li>based on the result, either the <xpath>then</xpath> or the <xpath>else</xpath> part is evaluated</li>
							<li>the else part may not be omitted</li>
						</ul>
					</ul>
					<pre>if ( … ) then … else …</pre>
					<pre>if ( @sex eq 'm' ) then 'Sir' else 'Madam'</pre>
					<pre>if ( @sex eq 'm' ) then 'Sir' else if ( @sex eq 'f' ) then 'Madam' else 'Whatever'</pre>
				</slide>
				<slide>
					<title>Less XSLT</title>
					<listing src="names.xml"/>
					<pre>first | last[not(../first)]</pre>
					<pre><![CDATA[<xsl:variable name="name">
	<xsl:choose>
		<xsl:when test="first">
			<xsl:value-of select="first"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="last"/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:variable>]]></pre>
					<pre>if ( exists(first) ) then first else last</pre>
				</slide>
			</part>
			<part id="xpath20-iterations">
				<title>Iterations</title>
				<slide>
					<title>Repeating Expression Evaluation</title>
					<ul>
						<li>Iteration repeatedly applies an expression to a sequence of items</li>
						<ul>
							<li>the notion of <link href="xpath20-sequences"/> is central to this concept</li>
							<li>this requires variables for binding and evaluation</li>
						</ul>
						<li>Iterations clearly demonstrate the change in expressiveness</li>
						<ul>
							<li>they introduce functionality which previously was limited to host languages</li>
						</ul>
					</ul>
					<pre>for $… in … return …</pre>
					<pre>for $i in //name return $i/last</pre>
					<pre>for $i in //name return if ( exists($i/first) ) then $i/first else $i/last</pre>
				</slide>
				<slide>
					<title>Iterations vs. Location Paths</title>
					<ul>
						<li>Every location path can be written using iterations</li>
						<pre>/names/name/last</pre>
						<pre>for $i in /names return for $j in $i/name return $j/last</pre>
						<li>Iterations are a more generalized way of evaluation</li>
						<ul>
							<li>path expressions work on nodes only</li>
							<pre>for $i in 1 to 10 return $i</pre>
							<li>path expression sort by document order and eliminate duplicates</li>
							<pre>//last/../..</pre>
							<pre>for $i in //last return for $j in $i/.. return $j/..</pre>
							<li>location steps change the context, iterations use the variable for this purpose</li>
						</ul>
						<li>Location paths are a useful syntax and method for tree navigation</li>
					</ul>
				</slide>
			</part>
			<part id="xpath20-quantified">
				<title>Quantified Expressions</title>
				<slide>
					<title>Testing Sequences</title>
					<ul>
						<li>Testing whether some or all items of a sequence satisfy a condition</li>
						<ul>
							<li>the notion of <link href="xpath20-sequences"/> is central to this concept</li>
							<li>this requires variables for binding and evaluation</li>
						</ul>
						<li>Quantifiers are well-known from query languages</li>
						<ul>
							<li><xpath>some</xpath> iterates over items and succeeds after the first success</li>
							<li><xpath>every</xpath> iterates over items and fails after the first failure</li>
							<li>both constructs are good candidates for optimization</li>
						</ul>
					</ul>
					<pre>( some | every ) $… in … satisfies …</pre>
					<pre>some $i in //*[@xlink:type='locator']/@xlink:href satisfies $i eq $query-uri</pre>
					<pre>every $i in //li/@id satisfies //*[@xlink:type='locator'][@xlink:href=concat('#', $i)]</pre>
				</slide>
			</part>
		</part>
		<part id="xpath20-sequences">
			<title>Sequences</title>
			<slide>
				<title>Major Changes</title>
				<ul>
					<li>XPath 1.0 has a very simple data model</li>
					<ol>
						<li>node sets: <code>//img[not(@alt)]</code></li>
						<li>number: <code>count(//img)</code></li>
						<li>string: <code>/descendant::img[3]/@src</code></li>
						<li>boolean: <code>starts-with(/html/@lang, 'en')</code></li>
					</ol>
					<li>XPath 2.0 needs a more powerful model for its advanced functionality</li>
					<ul>
						<li>everything in XPath 2.0 is a sequence</li>
						<li>sequences can contain a mix of items of various types</li>
						<li>sequences cannot be nested (there are no sequences of sequences)</li>
					</ul>
				</ul>
				<pre>every $i in ( 11, 22, 33, 'string' ) satisfies string(number($i)) ne 'NaN'</pre>
			</slide>
			<slide>
				<title>Divide and Conquer</title>
				<ul>
					<li>Sequences are part of XDM</li>
					<ul>
						<li>data models are separate entities from evaluation languages</li>
						<li>a data model can be reused in different evaluation languages</li>
					</ul>
					<li>XDM is far more complex than its predecessor, the Infoset</li>
					<ul>
						<li>XSD datatypes have been integrated into the data model</li>
						<li>Sequences allow more complex structures to exist</li>
					</ul>
					<li>Understanding the data model is key to understanding the language</li>
					<ul>
						<li>for simple XPaths, the mental model of XPath 1.0 works</li>
						<li>more advanced XPaths can only be understood when understanding XDM</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Applications</title>
			<slide>
				<title>Standalone</title>
				<ul>
					<li>XPath can be used in standalone XML tools</li>
					<ul>
						<li>editors provide XPath evaluation as <q>regular expressions for XML</q></li>
						<li>text-based searches in bigger XML documents are not a good idea</li>
					</ul>
					<li>Standalone tools are good for learning XPaths</li>
					<ul>
						<li>many tools support interactive evaluation</li>
						<li>seeing sequences visualized often is very helpful</li>
					</ul>
				</ul>
				<pre>for $i in ( 11, 22, 33, 'string' ) return ($i, number($i))</pre>
			</slide>
			<slide>
				<title>XQuery</title>
				<ul>
					<li><link href="xquery-1">XQuery</link> is built on top of XPath 2.0</li>
					<ul>
						<li>XPath allows constructing sequences based on documents</li>
						<li>XPath has no way of generating new document structures</li>
					</ul>
					<li>XQuery builds a query language around XPath</li>
					<ul>
						<li>the basic idea is to provide a language for constructing results from sequences</li>
						<li>~80% of the complexity of XQuery are in XPath 2.0</li>
					</ul>
				</ul>
				<pre ahref="http://www.stylusstudio.com/xquery_primer.html"><![CDATA[declare variable $firstName external;
<videos featuring="{$firstName}"> {
  let $doc := .
  for $v in $doc//video, $a in $doc//actors/actor
  where ends-with($a, $firstName) and $v/actorRef = $a/@id
  order by $v/year
  return
	<video year="{$v/year}"> { $v/title } </video> }
</videos>]]></pre>
			</slide>
			<slide>
				<title>XSLT 2.0</title>
				<ul>
					<li>XSLT 2.0 is based on <link href="xslt-1">XSLT 1.0</link> and built on top of XPath 2.0</li>
					<ul>
						<li>XPath allows constructing sequences based on documents</li>
						<li>XPath has no way of generating new document structures</li>
					</ul>
					<li>XSLT focuses on transformations rather than queries</li>
					<ul>
						<li><q>a query is a transformation is a query</q></li>
						<li>language preference is more a question of training and experience</li>
					</ul>
					<li>Many problems can be appropriately solved with both languages</li>
					<ul>
						<li>XQuery is favored by database people and by the big vendors</li>
						<li>XSLT 2.0 is favored by XML people who worked a lot with XSLT 1.0</li>
						<li>implementations could easily support both languages</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Easy Transition</title>
				<ul>
					<li>XPath 1.0 users can start using XPath 2.0 right away</li>
					<li>apart from a <a href="http://www.w3.org/TR/xpath20/#id-backwards-compatibility" title="XPath 2.0 Spec: Backwards Compatibility with XPath 1.0">few corner cases</a>, the results will be the same</li>
					<li>XPath 2.0 has a huge set of <a href="http://www.w3.org/TR/xpath-functions/">functions and operators</a></li>
					<li>XSD types can be used, values can be cast</li>
					<li>Regular expressions are supported for working with strings</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xmlapp" external="xml-in-application.pdf">
		<title>XML in Application</title>
		<date>2013-09-23</date>
		<toc class="author">Eric Kansa</toc>
		<toc class="resources"><a href="http://opencontext.org/">Open&#160;Context</a></toc>
		<toc class="abstract">Eric Kansa will discuss "open data" and some implementation strategies for realizing the goals of the open data movement. He will be drawing examples from Open Context, a research data sharing system focusing on archaeology. The discussion will explore pragmatic approaches to using XML and other structured data formats for publishing data on the Web to serve different communities with different levels of technical skills and capabilities.</toc>
	</presentation>
	<presentation id="xmlns">
		<title short="Namespaces">XML Namespaces</title>
		<date>2013-09-25</date>
		<toc class="resources"><a href="http://www.rpbourret.com/xml/NamespacesFAQ.htm#p1">XML Namespaces FAQ (Part I)</a>&#160;· <a href="http://www.w3.org/TR/REC-xml-names/" title="W3C XML Namespaces Specification">XML&#160;Namespaces&#160;Spec</a></toc>
		<toc class="abstract">XML is successful because it can be used in many different scenarios, and because it is easy to define a schema (such as a DTD) for new scenarios, producing a tailored XML data model for this scenario. This means that names in XML documents must be interpreted as belonging to a certain schema. As long as a document uses names from only one schema, this can be done rather easily. However, in many scenarios today documents combine names from different schemas, and <em>XML Namespaces</em> provide a mechanism how the names in an XML document can be associated with a namespace.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>How to think about Namespaces</title>
			<slide>
				<title>Namespaces are Simple</title>
				<ul>
					<li>XML Namespaces are often misunderstood</li>
					<ul>
						<li>the biggest problem is to get rid of some assumptions</li>
						<li>XML Namespaces are too simple and thus confusing</li>
					</ul>
					<li>Instincts of Web users</li>
					<ol>
						<li>URIs identify something that can be retrieved by a browser</li>
						<li>URIs identify something that can be displayed by a browser</li>
						<li>if I cannot get it and cannot look at it, what good can it be?</li>
					</ol>
					<li>However, these assumptions are not always true</li>
					<ol>
						<li>URIs identify <em>resources</em> which often, but not always, can be accessed over the Web</li>
						<li>URIs identify <em>resources</em> which often, but not always, have a Web-accessible representation</li>
						<li>sharing URIs means sharing an identity, which can mean sharing semantics (associated with this identity)</li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>Simple Examples</title>
				<listing src="mathml1.xml" line="2-6"/>
				<listing src="mathml2.xml" line="2-6"/>
				<listing src="mathml3.xml" line="2-6"/>
				<listing src="mathml4.xml" line="2-6"/>
			</slide>
			<slide>
				<title>Name Spaces</title>
				<ul>
					<li>Names are one form of identification</li>
					<li>Identification is essential for communications</li>
					<li>Names in XML are not suitable for identification</li>
					<ul>
						<li>they are local to their context (where they are defined)</li>
						<li>if the context is uniquely identified, the names would be, too</li>
					</ul>
					<li>Name Spaces: <em>Put names into spaces</em></li>
					<ul>
						<li>how to identify the space? Web identifiers are URIs!</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>URI Philosophy</title>
				<ul>
					<li><link href="uri"/> uniquely identify resources</li>
					<li>URIs often provide access information</li>
					<ul>
						<li>pretty clear in <code>http://dret.net/lectures/xml-fall13/</code></li>
						<li>less clear in <code>urn:ietf:rfc:2648</code> (<a href="http://tools.ietf.org/html/rfc2648">RFC 2648</a>)</li>
						<li>very (and purposely) unclear in <code>tag:9327493874329</code> (<a href="http://tools.ietf.org/html/rfc4151">RFC 4151</a>)</li>
					</ul>
					<li>URIs often return <em>resource representations</em></li>
					<ul>
						<li>the resource itself is never returned (how to return a <em>lecture</em>?)</li>
						<li>some representation often is useful (HTML, PDF, maybe video/audio)</li>
						<li>the resource exists and is useful without a representation!</li>
						<li><code href="http://maps.google.com/maps?ll=37.87133,-122.258463&amp;om=1">geo:37.87133;-122.258463</code> is not an <q>information resource</q> (but it exists)</li>
					</ul>
					<li>URIs are much more than just addresses of HTML pages</li>
				</ul>
			</slide>
			<slide>
				<title>The Namespace Problem</title>
				<ul>
					<li>People assume that URIs point to Web pages</li>
					<ul>
						<li>a <em>namespace name</em> (a URI) may point to a Web page</li>
						<li>it may also have no Web page associated with it</li>
						<li>it may even use a URI scheme which cannot be retrieved</li>
						<li>but it is always possible to compare URIs (<q>Do I know this namespace?</q>)</li>
					</ul>
					<li>People assume some standardized content format</li>
					<ul>
						<li>friendly namespaces provide HTML portals (<a href="http://www.w3.org/1999/xhtml">XHTML</a> and <a href="http://www.w3.org/1999/XSL/Transform">XSLT</a>)</li>
						<li>some namespaces just give you the schema (<a href="http://www.w3.org/2001/12/soap-envelope">SOAP</a>)</li>
						<li>they all are correct, because no resource representation is required!</li>
						<li>very unfriendly namespaces may return a 404 or even use inaccessible schemes</li>
					</ul>
					<li>Namespaces are used by comparing URIs</li>
					<ul>
						<li>anything else maybe useful, but is not required and unsafe on the Web</li>
						<li>when searching for a namespace definition, use Google (string search)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Using Namespaces</title>
			<slide>
				<title>Declaring Namespaces</title>
				<ul>
					<li>Using a namespace means referencing names from it</li>
					<ul>
						<li>unfortunately, there is no standard way of writing these names</li>
						<li>however, the <q><a href="http://www.jclark.com/xml/xmlns.htm">Clark notation</a></q> is useful: <code>{http://www.w3.org/1999/xhtml}html</code></li>
						<li>Namespaces are first declared and then used</li>
					</ul>
					<li><xml>xmlns</xml>-prefixed attributes are used for declaring namespaces</li>
					<ul>
						<li>Default namespace: <elem>html xmlns="http://www.w3.org/1999/xhtml"</elem></li>
						<li>Prefix notation: <elem>xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml"</elem></li>
					</ul>
					<li>Namespace declarations are inherited and can be overwritten</li>
					<ul>
						<li>the default namespace can be undeclared</li>
						<li>Namespace declarations can be used in (too) many ways</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Unhealthy Namespace Usages</title>
				<ul>
					<li>Namespaces can be (and are) used in rather strange ways</li>
					<ul>
						<li>these are syntax variations of identical structures</li>
						<li>without a good (i.e., conforming) parser, interpretation is surprisingly hard</li>
						<li>copy/paste can become hard or impossible</li>
					</ul>
					<li>Namespaces can be <a href="http://lists.xml.org/archives/xml-dev/200204/msg00170.html">neurotic, borderline, psychotic, or normal</a></li>
					<li>Each of the insane cases complicates processing</li>
					<li>None of these has any real technical inaccuracies</li>
					<li>XML should be used with humans in mind</li>
				</ul>
			</slide>
			<slide>
				<title>Unhealthy Namespace Usages in Practice</title>
				<listing src="neurotic.xml" line="2-9"/>
				<listing src="borderline.xml" line="2-9"/>
				<listing src="psychotic.xml" line="2-9"/>
			</slide>
			<slide>
				<title>Elements and Attributes</title>
				<ul>
					<li>Namespaces often apply to elements and attributes</li>
					<ul>
						<li>if an element name has no prefix, it has no namespace or the default namespace is used</li>
						<li>if a name has a prefix, the prefix must be bound to a namespace name</li>
						<li>names like this are called <em>Qualified Names (QNames)</em></li>
					</ul>
					<li>Elements and Attributes are treated differently</li>
					<ul>
						<li>the default namespace only applies to unprefixed <em>element names</em></li>
						<li>as a result, unprefixed <em>attribute names</em> are in no namespace</li>
					</ul>
					<li>Applications should process namespaces and not just use local names</li>
					<ul>
						<li>naïve implementations will break when processing unhealthy instances</li>
						<li>implementing namespaces is not very hard (but not trivial either)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Defining Namespaces</title>
			<slide>
				<title>Any URI is Possible</title>
				<ul>
					<li>A namespace name is a URI, that's all!</li>
					<ul>
						<li>it may not be accessible (because of the URI scheme)</li>
						<li>when retrieving it, nothing may be returned</li>
						<li>when retrieving it, something may be returned</li>
					</ul>
					<li>The only important thing is <em>the name</em></li>
					<ul>
						<li>the name is mentioned in the documentation</li>
						<li>if you know the documentation, you known the name</li>
						<li>shared names mean shared knowledge</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Namespace Definitions</title>
				<ul>
					<li>Namespaces can be defined by a <link href="dtd"/> (<a href="http://www.w3.org/TR/xhtml1/#strict">XHTML</a>)</li>
					<li>Namespaces can be defined by <link href="xsd-1"/> (<a href="http://www.w3.org/TR/soap12-part1/#tabnsprefixes">SOAP</a>)</li>
					<li>Namespaces can be defined by <link href="relax-ng"/> (<a href="http://www.w3.org/TR/xhtml2/conformance.html#strict">XHTML 2.0</a>)</li>
					<li>Namespaces can be defined by prose (<a href="http://www.w3.org/TR/xslt#xslt-namespace">XSLT</a>)</li>
					<li>If schemas are provided, additional information is required</li>
					<ul>
						<li>it is unlikely that a namespace can be fully described by a schema</li>
						<li>additional constraints and semantics are specified in prose</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Fixed or Extensible?</title>
				<ul>
					<li>Can a namespace change over time?</li>
					<ul>
						<li>may the namespace description become outdated? extended? replaced?</li>
						<li>this should be clearly documented in the namespace description</li>
					</ul>
					<li>The XML XML Namespace was widely believed <a href="http://www.w3.org/XML/1998/namespace">to be defined by XML</a></li>
					<ul>
						<li><xml>xml:lang</xml> and <xml>xml:space</xml> defined by XML</li>
						<li>but then <xml>xml:base</xml> was added by <em href="http://www.w3.org/TR/xmlbase/">XML Base</em></li>
						<li>and then <xml>xml:id</xml> was added by <link href="xml:id"><code>xml:id</code></link></li>
					</ul>
					<li>When defining namespaces, plan ahead and publish everything</li>
					<ul>
						<li>dependencies, change management, and versioning issues are important</li>
						<li>there still is no established standard for namespace descriptions</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Processing Namespaces</title>
			<slide id="namespace-validity">
				<title>Namespaces and Validity</title>
				<ul>
					<li>Namespaces define an additional layer on top of XML</li>
					<ul>
						<li>they define additional semantics (assignment to namespaces)</li>
						<li>they define additional constraints (declaration and usage of namespaces)</li>
					</ul>
					<li>Namespace-awareness is a basic requirement for XML tools</li>
					<ul>
						<li>XML not compliant with XML Namespaces will break most tools</li>
						<li>processing namespaces should be done by tools</li>
						<li>a namespace-aware parser translates namespace declarations into nodes</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Namespaces in the Document</title>
				<listing src="mathml4.xml"/>
			</slide>
			<slide>
				<title>Namespaces in the Tree</title>
				<img src="xmlns-tree.png" style="width : 90% ; margin : 4% ; "/>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Name Spaces</title>
				<ul>
					<li><q>Bags of Names</q> with a URI as a label</li>
					<li>The URI does not necessarily return anything</li>
					<li>Namespaces can be defined in any way (e.g., schemas)</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xsd-1">
		<title short="XSD 1">XML Schema (XSD) – Part I</title>
		<date>2013-09-30</date>
		<toc class="resources"><a href="http://www.w3.org/XML/Schema" title="W3C XML Schema Home">XML Schema</a></toc>
		<toc class="abstract">The <em>XML Schema Definition Language (XSD)</em> is the most popular schema language for XML today. It has been introduced to overcome some of the commonly observed limitations of DTDs, most notably the lack of typing. <em>Simple Types</em> describe content which is not structured by XML markup, which means it describes attribute values and element content. Simple types can be defined by deriving new types from existing types by using type restriction.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>Bad Names</title>
			<blockquote>XML Schema is a language for describing an XML schema.<br/>An XML schema can be defined using XML Schema.<br/>I would like to use XML Schema for my XML schema.</blockquote>
			<ul>
				<li>The two most awkward name choices in the XML arena:</li>
				<ol>
					<li><em>XML Schema</em>, which is simply <u>a</u> XML schema language (among many others)</li>
					<li><em>Open XML</em>, which is simply an XML language for encoding office documents</li>
				</ol>
				<li>Naming things means <q>getting into people's heads</q></li>
				<ul>
					<li>pretentious and all-embracing name choices serve a certain purpose</li>
					<li><em>XSD</em> and <em>WXS</em> are two semi-official acronyms for XML Schema</li>
				</ul>
				<li>Good news: <em>XML Schema</em> <a href="http://dret.typepad.com/dretblog/2008/06/new-w3c-drafts-xsd-rdfa.html">has been renamed</a> (<a href="http://dret.typepad.com/dretblog/2007/08/xml-schema-11-x.html">after being renamed</a>)</li>
				<ul>
					<li><em>XSD</em> now is the official acronym for the <em>XML Schema Definition Language</em></li>
					<li>(very officially, this name change affects version 1.1 of the language only …)</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>What's Wrong With DTDs?</title>
			<ul>
				<li>DTDs do not support application-level datatypes</li>
				<ul>
					<li>XML for B2B is very data-centric and needs typing</li>
					<li>SGML was created for documents where typing was less important</li>
				</ul>
				<li>DTDs do not support any relationships between markup constructs</li>
				<ul>
					<li>content models cannot be reused</li>
					<li>attribute lists cannot be reused</li>
					<li>structural relationships cannot be exploited in the DTD</li>
					<li><link href="param-entity"/> are used as a hack to work around this limitation</li>
				</ul>
				<li>DTD + XML Namespaces = Bad idea!</li>
			</ul>
		</slide>
		<slide>
			<title>Different Levels of Semantics</title>
			<ul>
				<li>XSD's simple data type provide some semantics</li>
				<ul>
					<li>a formerly undescribed attribute can now be described as being a <xsdtype>date</xsdtype></li>
					<li>it can be understood as being a date and inserted into a calendar</li>
					<li>but what kind of date is it? a birthday? an order date? a shipping date?</li>
					<li>a question of the <em>context</em> of where the <xsdtype>date</xsdtype> appears</li>
				</ul>
				<li>XSD better supports model-level information</li>
				<ul>
					<li>however, XSD also only captures part of the application semantics</li>
					<li>XSD is usually more specific than a DTD, because it contains types</li>
					<li>types provide information about the basic datatypes being used</li>
					<li>additional semantics (e.g., different kinds of dates) must be documented elsewhere</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>Schema-Validation and Applications</title>
			<img src="schema-valid-documents.png" style="width : 90% ; margin : 4% ; "/>
		</slide>
		<slide>
			<title>Validation and Typing</title>
			<ul>
				<li>XSD does two things at the same time:</li>
			</ul>
			<ol>
				<li>Validation checks for structural integrity (is the document <em>schema-valid</em>?)</li>
				<ul>
					<li>checking elements and attributes for proper usage (as with DTDs)</li>
					<li>checking element contents and attribute values for proper values</li>
				</ul>
				<li>Type annotations make the types available to applications</li>
				<ul>
					<li>instead of having to look at the schema, applications get the <em>Post-Schema Validation Infoset (PSVI)</em></li>
					<li>type-based applications (such as XSLT 2.0) can work on the typed instance</li>
				</ul>
			</ol>
		</slide>
		<slide>
			<title>XSD Syntax</title>
			<img src="xml-technology-syntaxes.png" style="width : 90% ; margin : 4% ; "/>
		</slide>
		<part id="xsd-types">
			<title>XSD Types</title>
			<slide>
				<title>What is a Type?</title>
				<ul>
					<li>A type is a <em>set of values</em></li>
					<ul>
						<li>the values can be enumerated (<em>home, mobile, office</em>)</li>
						<li>the values can be described by extension (intervals, regular expressions)</li>
					</ul>
					<li>DTD have (almost) no types</li>
					<ul>
						<li>element content is always <xml>#PCDATA</xml> (any number of any characters)</li>
						<li>attributes most often are <xml>CDATA</xml>  (any number of any characters)</li>
						<li>attributes may have enumerated types (but no extensional types)</li>
						<li>attributes may use <link href="ididref"/></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XSD vs. DTD</title>
				<div style="margin : 2% ; ">
					<table width="90%" cellspacing="20">
						<col/>
						<colgroup span="2"/>
						<thead>
							<tr>
								<td/>
								<th>DTD</th>
								<th>XSD</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th>Concepts</th>
								<td colspan="2" align="center">some conceptual model (formal/informal)</td>
							</tr>
							<tr>
								<th>Types</th>
								<td style="color : gray ; "><xml>ID/IDREF</xml> and (<xml>#P</xml>)<xml>CDATA</xml></td>
								<td>Hierarchy of Simple and Complex Types</td>
							</tr>
							<tr>
								<th>Markup Constructs</th>
								<td>Element Type Declarations<br/><xml>&lt;!ELEMENT order …</xml></td>
								<td>Element Definitions<br/><xml>&lt;xs:element name="order"> …</xml></td>
							</tr>
							<tr>
								<th>Instances (Documents)</th>
								<td colspan="2" align="center"><xml>&lt;order date=""> [ order content ] &lt;/order></xml></td>
							</tr>
						</tbody>
					</table>
				</div>
			</slide>
			<slide>
				<title>Document/Data Perspectives</title>
				<ul>
					<li>XML as documents is text interspersed with structure</li>
					<ul>
						<li>XML captures text structures that support document processing</li>
						<li>without these structures, the text remains usable (as unstructured text)</li>
						<li>structure is good, but not indispensable</li>
					</ul>
					<li>XML as data is structure filled with data</li>
					<ul>
						<li>programmers think about classes and objects, so they need types</li>
						<li>without structure, data-centric XML is completely useless</li>
						<li>programmers often view XML as wire format and types as the portal to their objects</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="xsd-simple-types">
			<title>Simple Types</title>
			<slide>
				<title>What are Simple Types?</title>
				<ul>
					<li>Simple types describe values not structured by XML markup</li>
					<ul>
						<li>they describe attribute values (<xml>date="2006-10-03"</xml>)</li>
						<li>they describe element content (<code>&lt;phone>+1-510-6432253&lt;/phone></code>)</li>
					</ul>
					<li>Simple types can be used for elements or attributes</li>
					<ul>
						<li>XSD treats contents in elements and attributes equally</li>
						<li>simple type libraries can be designed independent of their eventual use</li>
					</ul>
					<li>Simple types are available in three flavors</li>
					<ul>
						<li><em>atomic types:</em> one value of one type (one number in some range)</li>
						<li><em>union types:</em> one value of a union of types (a number or the string <q><code>undefined</code></q>)</li>
						<li><em>list types:</em> a whitespace-separated list of values (<elem>phone type="home office"</elem>)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Named vs. Anonymous</title>
				<ul>
					<li>Types can be <em>named</em> or <em>anonymous</em></li>
					<ul>
						<li>named types have a name and can be referenced (and thus be reused)</li>
						<li>anonymous types have no name and can only be used where they are defined</li>
					</ul>
				</ul>
				<listing src="named-anonymous-simple.xsd" line="3-9"/>
				<listing src="named-anonymous-simple.xsd" line="17-23"/>
			</slide>
			<slide>
				<title>Type Definitions</title>
				<ul>
					<li>Simple types are sets of values</li>
					<ul>
						<li>named simple types are sets of values with a name (and thus reusable)</li>
						<li>anonymous simple types are sets of values defined where they are needed</li>
					</ul>
					<li>Simple types are defined to represent model-level information</li>
					<ul>
						<li>in most cases, they will have restrictions associated with them</li>
						<li>they may also simply be tags for semantics (fax and phone numbers share the same value space)</li>
					</ul>
					<li>XSD has a library of <em>built-in datatypes</em></li>
					<ul>
						<li><em>ur-types</em> are the conceptual grounding of all types</li>
						<li><em>primitive types</em> are the types that are there <q>by definition</q></li>
						<li><em>derived types</em> are based on primitive types</li>
						<li>users can derive their own types using <link href="xsd-simple-type-restriction"/></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Type Hierarchy</title>
				<img style="height : 75% ; margin : 2% ; " src="xsd-type-hierarchy.gif" href="http://www.w3.org/TR/xmlschema-2/#built-in-datatypes"/>
			</slide>
			<part id="xsd-simple-type-restriction">
				<title>Simple Type Restriction</title>
				<slide>
					<title>Built-In Types</title>
					<listing src="built-in.xsd"/>
				</slide>
				<slide>
					<title>How to Restrict</title>
					<ul>
						<li>Simple types can be derived by restriction</li>
						<ul>
							<li>the <em>base type</em> must be a simple type</li>
							<li>the <em>derived type</em> will be a simple type</li>
							<li>all simple types form a tree, rooted at the <code>anySimpleType</code></li>
						</ul>
						<li>Restriction are based on facets</li>
						<ul>
							<li>each restriction can use <em>0-n</em> facets</li>
							<li>facets can be refined in further simple type restrictions</li>
							<li>XSD designers should try to restrict types as much as possible</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Facets</title>
					<ul>
						<li>Facets define a certain way of restricting a simple type</li>
						<ul>
							<li>facets are independent, but they may interact (<code>minLength</code> and <code>maxLength</code>)</li>
							<li>XSD defines 12 <em>constraining facets</em> which may be used for restrictions</li>
							<li><code>length, minLength, maxLength, pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minExclusive, minInclusive, totalDigits, fractionDigits</code></li>
						</ul>
						<li>Facets may be repeated in different levels of the type hierarchy</li>
						<ul>
							<li>they may only further restrict the facet (e.g., reducing the <code>maxLength</code>)</li>
							<li>facets apply to all directly or indirectly derived subtypes</li>
							<li>facets may be <em>fixed</em> (no further restriction is allowed)</li>
						</ul>
						<li>Not all facets are applicable to all types</li>
						<ul>
							<li>the applicability depends on the <em>primitive type</em> being used</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Facet Applicability</title>
					<div style="margin : 2% ; ">
						<table width="90%">
							<tr>
								<th align="right" valign="top"><code>string</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>boolean</code></th>
								<td>pattern, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>float</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>double</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>decimal</code></th>
								<td>totalDigits, fractionDigits, pattern, whiteSpace, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>duration</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>dateTime</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>time</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>date</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gYearMonth</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gYear</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gMonthDay</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gDay</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>gMonth</code></th>
								<td>pattern, enumeration, whiteSpace, maxInclusive, maxExclusive, minInclusive, minExclusive</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>hexBinary</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>base64Binary</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>anyURI</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>QName</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
							<tr>
								<th align="right" valign="top"><code>NOTATION</code></th>
								<td>length, minLength, maxLength, pattern, enumeration, whiteSpace</td>
							</tr>
						</table>
					</div>
				</slide>
				<slide>
					<title>Patterns</title>
					<ul>
						<li>Patterns restrict the <em>lexical space</em> of simple types</li>
						<ul>
							<li>most other facets restrict the <em>value space</em> (e.g., intervals of numbers)</li>
							<li>in many cases, patterns are useful additions to value-oriented facets</li>
						</ul>
						<li>Patterns are <a href="http://www.w3.org/TR/xmlschema-2/#regexs">regular expressions</a></li>
						<ul>
							<li>they support many common regex constructs and Unicode</li>
							<li>the language pattern allows <q><code>de</code></q>, <q><code>de-CH</code></q>, and other tags</li>
							<li>the pattern checks for lexical correctness, not against a code list</li>
						</ul>
					</ul>
					<pre>([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]{1,8})(-[a-zA-Z]{1,8})*</pre>
				</slide>
				<slide>
					<title>Simple Type Examples</title>
					<listing src="simple-examples.xsd"/>
				</slide>
				<slide>
					<title>Facet Limitations</title>
					<ul>
						<li>Facets limit one dimension of a type's value space</li>
						<ul>
							<li>using <code>pattern</code>, the lexical space can also be restricted</li>
							<li>restrictions should be made as specific as possible</li>
							<li>no limitations are possible beyond the predefined facets</li>
						</ul>
						<li>There is no connection to the context within the document</li>
						<ul>
							<li>facets cannot make references to other values (e.g., neighboring attributes)</li>
						</ul>
						<li>Additional constraints should be documented</li>
						<ul>
							<li>documentation enables applications to implement constraint checking</li>
							<li>other schema languages may be used to express these constraints</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Typed XML Content</title>
				<ul>
					<li>XSD introduces a <q>type layer</q> to schema languages</li>
					<li>Types facilitate abstractions (and thus modeling)</li>
					<li>Simple types can be restricted to yield more specific types</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xsd-2">
		<title short="XSD 2">XML Schema (XSD) – Part II</title>
		<date>2013-10-02</date>
		<toc class="resources"></toc>
		<toc class="abstract">XSD <em>Complex Types</em> describe element content if this content is using attributes and/or element content other than only character data. Thus, complex types are used to define the allowed markup structures for a class of documents. Using XSD's type concepts, it is easier to represent model-level information in a schema, because type hierarchies can represent model-level specializations.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="xsd-complex-types">
			<title>Complex Types</title>
			<slide>
				<title>What is a Complex Type?</title>
				<ul>
					<li>Complex types describe the allowed element content</li>
					<ul>
						<li>they describe what the element may contain (the element's <em>content model</em>)</li>
						<li>they describe the attributes that an element may have (the element's <em>attribute list</em>)</li>
					</ul>
					<li>Complex types do not define the element name</li>
					<ul>
						<li>the complex type defines which content is allowed for the element</li>
						<li>the element definition uses the complex type to define the allowed element content</li>
					</ul>
					<li>Complex types have similar properties to simple types</li>
					<ul>
						<li>they can be named or anonymous</li>
						<li><link href="xsd-complex-type-derivation"/> can be used to construct a type hierarchy</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Complex Type Example</title>
				<listing src="complex-example.xsd"/>
			</slide>
			<slide>
				<title>Complex Types &amp; Content Types</title>
				<ul>
					<li>Complex types can have different kinds of content</li>
					<ul>
						<li><em>simple content</em> refers to simple type content using additional attributes</li>
						<li><em>complex content</em> is anything else (anything beyond <em>simple type content</em>)</li>
					</ul>
					<li><link href="xsd-complex-type-derivation"/> heavily depends on this classification</li>
				</ul>
				<div style="margin : 2% ; ">
					<table width="90%" cellspacing="20" rules="all" frame="border">
						<tr>
							<th rowspan="3">Simple Types</th>
							<th colspan="4">Complex Types</th>
						</tr>
						<tr>
							<th rowspan="2">Simple Content</th>
							<th colspan="3">Complex Content</th>
						</tr>
						<tr>
							<td align="center">Element Only</td>
							<td align="center">Mixed</td>
							<td align="center">Empty</td>
						</tr>
					</table>
				</div>
			</slide>
			<part>
				<title>Content Models</title>
				<slide>
					<title>DTD Content Models</title>
					<ul>
						<li><link href="dtd-element"/> in DTDs uses a compact syntax</li>
						<ul>
							<li>XSD supports the same facilities with a more verbose syntax</li>
							<li>XSD adds features which DTDs do not support</li>
						</ul>
						<li>DTDs allow elements to be mandatory, optional, repeatable, or optional and repeatable</li>						
						<ul>
							<li>XSD allows the cardinality to be specified</li>
						</ul>
						<li>DTDs allow sequences (<q><code>,</code></q>) and alternatives (<q><code>|</code></q>)</li>
						<ul>
							<li>XSD introduces a (very limited) operator for <em>all groups</em></li>
						</ul>
						<li>Apart from the syntax, XSD content models are not very different</li>
					</ul>
				</slide>
				<slide>
					<title>Mixed Content</title>
					<ul>
						<li>DTDs define mixed content by mixing <code>#PCDATA</code> into the content model</li>
						<ul>
							<li>DTDs always require mixed content to use the form <code>( #PCDATA | a | b )*</code></li>
							<li>the occurrence of elements in mixed content cannot be controlled</li>
						</ul>
						<li>XSD defines mixed content outside of the content model</li>
						<ul>
							<li>the content model is defined like an element-only content model</li>
							<li>the <code>mixed</code> attribute on the type marks the type as being mixed</li>
						</ul>
						<li>XSD mixed content can use all model groups</li>
						<ul>
							<li>it is possible to constrain element occurrences in the same way as in element-only content</li>
							<li>in practice, this feature is rarely used (mixed content often is very loosely defined)</li>
						</ul>
					</ul>
					<listing src="global-local.xsd" line="3-11"/>
				</slide>
				<slide>
					<title>Empty Content</title>
					<ul>
						<li>DTDs have a special keyword for empty elements</li>
						<ul>
							<li>instead of the content model, the keyword <code>EMPTY</code> is used</li>
							<li>empty elements may still have attribute lists associated with them</li>
						</ul>
						<li>XSD empty types are defined implicitly</li>
						<ul>
							<li>there is no explicit keyword for defining an empty type</li>
							<li>if a type has no model group inside it, it is empty (it still may have attributes)</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>XSD Design Patterns</title>
			<slide>
				<title>Global Elements? Named Types?</title>
				<ul>
					<li>XSD's design dimensions allow different strategies</li>
					<li>Elements/attributes can be defined as <em>local</em> or <em>global</em></li>
					<ul>
						<li><em>local</em> elements/attributes are defined where they are used</li>
						<li><em>global</em> elements/attributes are globally defined and then referenced</li>
						<li>elements/attributes which should be reused must be defined as global</li>
					</ul>
					<li>Types can be defined as <em>anonymous</em> or <em>named</em></li>
					<ul>
						<li><em>anonymous</em> types are defined where they are used</li>
						<li><em>named</em> types are globally defined and then referenced</li>
						<li>types which should be reused must be defined as named</li>
					</ul>
					<li>XSD design patterns can favor one type of definition</li>
					<ul>
						<li>reuse always required <em>global</em> elements/attributes and <em>named</em> types</li>
						<li>having everything <em>global/named</em> results in bigger schema</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Sample XML</title>
				<listing src="design-sample.xml"/>
			</slide>
			<part>
				<title>Russian Doll</title>
				<slide>
					<title>Russian Doll XSD</title>
					<listing src="russian-doll.xsd"/>
				</slide>
				<slide>
					<title>Russian Doll Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="russian-doll.gif" title="Russian Doll XSD"/>
				</slide>
			</part>
			<part>
				<title>Venetian Blinds</title>
				<slide>
					<title>Venetian Blinds XSD</title>
					<listing src="venetian-blinds.xsd"/>
				</slide>
				<slide>
					<title>Venetian Blinds Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="venetian-blinds.gif" title="Venetian Blinds XSD"/>
				</slide>
			</part>
			<part>
				<title>Salami Slice</title>
				<slide>
					<title>Salami Slice XSD</title>
					<listing src="salami-slice.xsd"/>
				</slide>
				<slide>
					<title>Salami Slice Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="salami-slice.gif" title="Salami Slice XSD"/>
				</slide>
			</part>
			<part>
				<title>Garden of Eden</title>
				<slide>
					<title>Garden of Eden XSD</title>
					<listing src="garden-of-eden.xsd"/>
				</slide>
				<slide>
					<title>Garden of Eden Structure</title>
					<img style="width : 75% ; margin : 4% ; " src="garden-of-eden.gif" title="Garden of Eden XSD"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Local and Global Definitions</title>
			<slide>
				<title>Named and Anonymous Types</title>
				<ul>
					<li>Types can be named or anonymous</li>
					<ul>
						<li>named types can be reused (for elements, attributes, or type derivation)</li>
						<li>anonymous types can only be used where they are defined</li>
					</ul>
					<li>DTD <q>types</q> are always anonymous (they cannot be reused)</li>
				</ul>
				<pre>&lt;!ELEMENT person <span style="color : red ; ">(name, address) >
&lt;!ATTLIST person id ID #REQUIRED ></span></pre>
				<ul>
					<li>DTDs have everything hardcoded</li>
					<ul>
						<li>complex types are always locally defined</li>
						<li>elements are always globally defined</li>
						<li>attributes are always locally defined</li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>Elements</title>
				<slide>
					<title>Local vs. Global Elements</title>
					<ul>
						<li>Elements can be defined in a type or in the schema</li>
						<ul>
							<li>local elements can only be used where they are defined</li>
							<li>global elements can be reused, they can serve as building blocks</li>
						</ul>
						<li>Elements and complex types depend on each other</li>
						<ul>
							<li>an element is defined by a type, often this will be a complex type</li>
							<li>a complex type is defined by its contents, which are elements and/or attributes</li>
						</ul>
					</ul>
					<listing src="global-local.xsd" line="4-12"/>
				</slide>
				<slide>
					<title>Reusable Elements</title>
					<listing src="complex-example.xsd"/>
				</slide>
			</part>
			<part>
				<title>Attributes</title>
				<slide>
					<title>Attribute Definitions</title>
					<ul>
						<li>DTDs treat attributes as something entirely different from element content</li>
						<ul>
							<li>they are defined in an <code>ATTLIST</code>, not in the <code>ELEMENT</code> definition</li>
							<pre>&lt;!ELEMENT person (name, address) >
<span style="color : red ; ">&lt;!ATTLIST person id ID #REQUIRED ></span></pre>
							<li>they have a special range of <link href="dtd-attr-type"/> as opposed to elements</li>
							<pre>&lt;!ATTLIST person id <span style="color : red ; ">ID</span> #REQUIRED ></pre>
						</ul>
						<li>XSD overcomes these restrictions only partially</li>
						<ul>
							<li><link href="xsd-simple-types"/> are used to define attribute (or element) contents</li>
							<li>attributes are still described as something entirely different from an element's content model</li>
						</ul>
						<li>Attributes could be better integrated into the model</li>
						<ul>
							<li><link href="relax-ng"/> treats attributes as part of an element's content model</li>
							<li>this makes it trivial to have choices of element content and attributes</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Reusing Attributes</title>
					<ul>
						<li>DTDs treat attributes as something local to an element</li>
						<ul>
							<li>attributes are defined in an element's <code>ATTLIST</code></li>
							<li>reusing attributes for more than on element requires <link href="param-entity"/></li>
						</ul>
						<li>XSD better supports reuse of schema components</li>
						<ul>
							<li>types can be defined locally (anonymous) or globally (named)</li>
							<li>elements and attributes can be defined globally or locally</li>
						</ul>
						<li>Globally defined attributes can be reused</li>
						<ul>
							<li>the attribute definition does not tie it to any occurrence</li>
							<li>the attribute can then be referenced from an complex type definition</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Reusing Attributes (Example)</title>
					<listing src="global-local.xsd"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Typed XML Structures</title>
				<ul>
					<li>XSD introduces a <q>type layer</q> to schema languages</li>
					<li>Types facilitate abstractions (and thus modeling)</li>
					<li>Complex types define how elements have to be used</li>
					<li>Designing XSD can be done in many different ways</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xsd-3">
		<title short="XSD 3">XML Schema (XSD) – Part III</title>
		<date>2013-10-07</date>
		<toc class="resources"><a href="http://www.awprofessional.com/articles/printerfriendly.asp?p=31477&amp;rl=1">XSD Identity Constraints</a></toc>
		<toc class="abstract">XSD allows greater flexibility in defining constraints on intra-document references than the ID/IDREF construct of DTDs. XSD's <em>Identity Constraints</em> are scoped, typed, and can be used for elements or attributes. They are more powerful that the DTD's limited ID/IDREF mechanism, but still lack sufficient generality to support a really wide set of model constraints to be expressed. XSD complex types can be derived by <em>restriction</em> or <em>extension</em>. Complex type restriction defines the restricted type to be a more restricted version of the base type. Complex type extension make it possible to extend the base type by either adding attributes or contents (only by appending new content to the content model). Complex type derivation allows XSD to express type hierarchies of complex types, which can be aligned with more or less specialized code for processing instances of these types.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="xsd-names">
			<title>Names and Namespaces</title>
			<slide>
				<title>Definitions</title>
				<ul>
					<li>Many XSDs define a vocabulary for a namespace</li>
					<ul>
						<li>DTDs do not have any support for namespaces</li>
						<li>XSD heavily builds on <link href="xmlns"/></li>
					</ul>
					<li>XSD provides support for declaring a vocabulary's namespace</li>
					<pre>&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" <span style="color : red ; ">targetNamespace="http://www.example.com/"</span>></pre>
					<li>Schema-validation can check for proper namespace usage</li>
					<ul>
						<li>the <xml>targetNamespace</xml> has to be used in the instance</li>
						<li>if the namespace does not match, validation cannot succeed</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Instances</title>
				<ul>
					<li>The schema defines the <xml>targetNamespace</xml> of the vocabulary</li>
					<ul>
						<li>all globally defined elements, attributes, and types are in that namespace</li>
						<li>the instances must declare and use the namespace to be schema-valid</li>
					</ul>
				</ul>
				<listing src="multicol.html" line="2-5"/>
				<ul>
					<li>A <em>prefixed name</em> is not the same as a <em>qualified name</em></li>
					<ul>
						<li>if there is a default namespace, unprefixed elements are still qualified</li>
					</ul>
					<li>Nasty details about XML Namespaces and attributes</li>
					<ul>
						<li>the default namespace does <em>not</em> apply to attributes</li>
						<li>attributes must therefore <em>always be prefixed</em> if they need to be qualified</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Name Qualification</title>
				<ul>
					<li>Global elements and attributes have to be used as qualified names</li>
					<ul>
						<li>this means that they must be referred to by their namespace-qualified name</li>
						<li>if a default namespace is used, elements are qualified <em>without carrying a prefix</em></li>
						<li>since the default namespace does not apply to attributes, they always must be explicitly prefixed</li>
					</ul>
					<li>Local elements and attributes may be used qualified or unqualified</li>
					<ul>
						<li>this control <em>only applies to locally define elements or attributes</em></li>
						<li>the default defined by XSD is not a good choice</li>
						<li>because of how XML Namespaces work, a non-default choice is recommended</li>
					</ul>
					<li>XSD allows control over how local names have to be used</li>
				</ul>
				<pre>&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/" <span style="color : red ; ">elementFormDefault="qualified" attributeFormDefault="unqualified"</span>></pre>
			</slide>
		</part>
		<part>
			<title>Identity Constraints</title>
			<slide>
				<title>Element = Type + Constraints</title>
				<ul>
					<li>DTDs and XSD are mainly about specifying grammars</li>
					<ul>
						<li>types describe the allowed values using grammars</li>
						<li>grammar-oriented schemas have some nice properties</li>
					</ul>
					<li>DTD's <link href="ididref"/> allow additional constraints</li>
					<ul>
						<li>apart from the grammar definition, cross-references in the tree are supported</li>
						<li>validation checks the integrity of the cross-references, not only the tree</li>
					</ul>
					<li>DTD's ID/IDREF are a very simple mechanism</li>
					<ul>
						<li>they are always global</li>
						<li>they also define the type of the attribute (XML names)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Improvements over ID/IDREF</title>
				<ul>
					<li>XSD's <em>Identity Constraints</em> improve DTD's ID/IDREF</li>
					<li>Identity constraints are scoped and apply only to a selected set of nodes</li>
					<ul>
						<li>the constraint applies only to a selected set of nodes (using XPath)</li>
					</ul>
					<li>Identity constraints are evaluated using typed values</li>
					<ul>
						<li><code>ID</code>s must be XML names (no numbers allowed)</li>
						<li><q><code>2</code></q> ≟ <q><code>+00002</code></q> should be evaluated based on the type (string or decimal?)</li>
						<li>XSD separates the constraint from the type of the selected nodes</li>
					</ul>
					<li>Identity constraints may select elements or attributes</li>
					<ul>
						<li>XPaths are used to select the constrained values, they can select elements or attributes</li>
					</ul>
					<li>Multiple fields</li>
					<ul>
						<li>it is possible to select more than one field for a constraint (phone &amp; area code must be unique)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Types of Identity Constraints</title>
				<ul>
					<li>Uniqueness constraints</li>
					<ul>
						<li>if there is a field, it must have a unique value among the selected nodes</li>
					</ul>
					<li>Key constraints</li>
					<ul>
						<li>there must be a field, and it must have a unique value among the selected nodes</li>
					</ul>
					<li>Key reference constraints</li>
					<ul>
						<li>the field must refer to an existing value in the referred key</li>
						<li>if the key reference also is constrained by a key, only one reference may use the referred key</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Identity Constraint Definitions</title>
				<ul>
					<li>Identity constraints are part of an element definition</li>
					<li>There are <em>three important factors</em> to an identity constraint</li>
					<ol>
						<li>location of the identity constraint's definition</li>
						<li>the nodes to which the constraint should be applied</li>
						<li>the fields which are used to evaluate the constraint</li>
					</ol>
					<li>If the constraint is a key reference constraint, there is a <em>fourth factor</em></li>
					<ol start="4">
						<li>the key constraint that is used for checking the references</li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>Identity Constraint Evaluation</title>
				<img style="width : 90% ; margin : 4% ; " src="identity-constraints.png"/>
			</slide>
			<slide>
				<title>Advanced Identity Constraints</title>
				<img style="width : 90% ; margin : 4% ; " src="identity-constraints++.png"/>
			</slide>
		</part>
		<part id="xsd-complex-type-derivation">
			<title>Complex Type Derivation</title>
			<slide>
				<title>Types in XSD</title>
				<ul>
					<li><link href="xsd-simple-types"/> are used to model non-markup values</li>
					<li><link href="xsd-simple-type-restriction"/> is used to define simple user types</li>
					<li><link href="xsd-complex-types"/> are used to model markup structures</li>
					<li>Models often use generalization and specialization</li>
					<ul>
						<li>not all models use this modeling technique</li>
						<li>OO methods have made this very popular (UML is OO)</li>
					</ul>
					<li><link href="xsd-complex-type-derivation"/> is used to represent model hierarchies</li>
					<ul>
						<li>in theory, this could be used by generalized and specialized code</li>
						<li>in practice, the connection between XSD and code is too weak to be robust</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Type Derivation</title>
				<ul>
					<li>XSD supports the modeling approach of <em>specialization</em></li>
					<ul>
						<li>simple types can be restricted to create more specialized simple types</li>
						<li>each value of a restricted type is also a valid value of the more general type</li>
					</ul>
					<li>Complex types are combinations of content and attributes</li>
					<li>Specialization of complex types can be done in two ways</li>
					<ul>
						<li><link href="xsd-complex-type-restriction"/>: more restricted ways of using the content and/or attributes</li>
						<li><link href="xsd-complex-type-extension"/>: additional content and/or attributes may be used</li>
					</ul>
					<li>Both kinds of complex type derivation can be regarded as specialization</li>
					<ul>
						<li><link href="xsd-complex-type-restriction"/>: for US persons the country must always be set to <q><code>US</code></q></li>
						<li><link href="xsd-complex-type-extension"/>: people having an employee number are employees</li>
					</ul>
				</ul>
			</slide>
			<part id="xsd-complex-type-restriction">
				<title>Complex Type Restriction</title>
				<slide>
					<title>Removing Choices</title>
					<ul>
						<li>Complex types usually allow variability</li>
						<ul>
							<li><xml>minOccurs</xml> and <xml>maxOccurs</xml> allow variability in occurrences</li>
							<li><xml>choice</xml> groups allow to choose between a number of alternatives</li>
							<li>attributes may be flagged as <code>use="optional"</code></li>
							<li>simple types allow the individual values to use certain sets of values</li>
						</ul>
						<li>Complex type restriction allows restrictions of all these variations</li>
						<ul>
							<li><xml>minOccurs</xml> and <xml>maxOccurs</xml> can be made more restrictive</li>
							<li>alternatives can be removed from choice groups</li>
							<li>optional attributes can flagged as <code>use="required"</code> or <code>use="prohibited"</code></li>
							<li>the simple types of values can be set to more restricted simple types</li>
						</ul>
						<li>The technical way of defining restrictions is cumbersome</li>
						<ul>
							<li>when the base type changes, the restricted type has to be fixed by hand</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Complex Type Restriction (Example)</title>
					<listing src="complex-restriction.xsd"/>
				</slide>
				<slide>
					<title>Processing Restricted Complex Types</title>
					<ul>
						<li>Values of restricted types are values of the base types</li>
						<ul>
							<li>type restriction is defined so that restricted type values are always base type values</li>
							<li>code processing a type can be reused to process restricted types</li>
						</ul>
						<li>If there is a well-designed type hierarchy, programming becomes easier</li>
						<ul>
							<li>simple code can be written to handle the basic types</li>
							<li>if required, more advanced code can be written for the restricted types</li>
							<li>in many cases, restriction is more for validation than for processing</li>
						</ul>
						<li>XSDs may even use <em>abstract types</em></li>
						<ul>
							<li>no element will ever use the <xml>addressType</xml></li>
							<li>concrete elements will only use restricted types</li>
							<li>there can be code handling the <xml>addressType</xml> which handles all addresses</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xsd-complex-type-extension">
				<title>Complex Type Extension</title>
				<slide>
					<title>Adding Content</title>
					<ul>
						<li>Complex types are element content and attributes</li>
						<ul>
							<li>extensions can add content, but only at the end of the base content</li>
							<li>extensions can add attributes (order is not significant for attributes)</li>
						</ul>
						<li>Adding content to existing content may not change the existing content</li>
						<ul>
							<li>if the content is <em>element only</em>, it has to remain element only</li>
							<li>if the content is <em>mixed</em>, is has to remain mixed</li>
							<li>if the content is <em>empty</em>, it may become element only or mixed</li>
							<li>the reason for these rules is that <em>mixed</em> is a global property of a type</li>
						</ul>
						<li>Adding attributes simply adds these to the list of existing attributes</li>
						<ul>
							<li>the added attributes may be optional or required</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Complex Type Extension (Example)</title>
					<listing src="complex-extension.xsd"/>
				</slide>
				<slide>
					<title>Processing Extended Complex Types</title>
					<ul>
						<li>Values of extended types are <em>not</em> values of the base types</li>
						<ul>
							<li>type extension adds content add/or attributes to a type</li>
							<li>if content is added, it is always added at the end of the base type's content</li>
						</ul>
						<li>If there is a well-designed type hierarchy, programming becomes easier</li>
						<ul>
							<li>simple code can be written to handle the basic types</li>
							<li>if that should handle extended types, it must be written to handle extensions</li>
							<li><q>handling extensions</q> can be as simple as skipping them</li>
						</ul>
						<li>XSDs may even use <em>abstract types</em></li>
						<ul>
							<li>no element will ever use the <xml>addressType</xml></li>
							<li>concrete elements will only use extended types</li>
							<li>code handling extended types can build on code handling the base type</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XSD Features</title>
				<ul>
					<li>XSD allows defining a grammar for XML documents</li>
					<li>Identity constraints enable non-grammar constraints to be expressed</li>
					<li>XSD identity constraints are more powerful than the DTD ID/IDREF concept</li>
					<li>Only a subset of structural constraints can be expressed in XSD</li>
					<li>XSD 1.1 introduces the concept of <em>assertions</em> (XPath-based constraints)</li>
					<li>Types make it easier to turn a model into a grammar</li>
					<li>Some of the things we have not seen:</li>
					<ul>
						<li>named groups, modularizing schemas, wildcards, substitution groups, …</li>
					</ul>
				</ul>
			</slide>
			<slide id="schema-components">
				<title>Schema Components</title>
				<img style="height : 75% ; margin : 2% ; " src="schema-components.gif" title="Schema Components"/>
			</slide>
		</part>
	</presentation>
	<presentation id="presentation-preparation" external="project-schedule#preparation">
		<title>Project Presentation Preparation</title>
		<date>2013-10-09</date>
		<toc class="abstract">This slot is reserved for the project group to meet at prepare their project presentations.</toc>
	</presentation>
	<presentation id="presentations" external="project-schedule#presentation">
		<title>Project Presentations</title>
		<date>2013-10-14</date>
		<toc class="abstract">This slot is reserved for the project presentations, with each group getting an opportunity to present.</toc>
	</presentation>
	<presentation id="presentation-preparation" external="project-schedule#feedback">
		<title>Project Presentation Feedback</title>
		<date>2013-10-16</date>
		<toc class="abstract">This slot is reserved for the project groups to incorporate the feedback from the project presentations.</toc>
	</presentation>
	<presentation id="xslt-1">
		<title short="XSLT 1">XML Transformations (XSLT) – Part I</title>
		<date>2013-10-21</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xslt" title="W3C XSLT 1.0 Specification">XSLT&#160;1.0&#160;Spec</a></toc>
		<toc class="abstract">Because XML can be used to represent any vocabulary (often defined by some schema), the question is how these different vocabularies can be processed and maybe transformed into something else. This <q>something else</q> may be another XML vocabulary (a common requirement in B2B scenarios), or it may be HTML (a common scenario for Web publishing). Using <em>XSL Transformations (XSLT)</em>, mapping tasks can be implemented easily. XSLT leverages XPath's expressive power in a rather simple programming language, the programs are often called <em>stylesheets</em>. For easy tasks, XSLT mappings can be specified without much real <q>programming</q> going on, by simply specifying how components of the source markup are mapped to components of the target markup.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>XPath and XSLT</title>
			<ul>
				<li>XPath is an expression language</li>
				<ul>
					<li>location paths let you select parts of an XML document tree</li>
					<li>expressions in general may have other data types as well (string, number, boolean)</li>
				</ul>
				<li>XSLT is a programming language based on XPath</li>
				<ul>
					<li>XSLT defines the structures for the control flow within the program</li>
					<li>in all the places where something is evaluated, XPaths are being used</li>
					<li>sometimes, one can substitute for the other</li>
				</ul>
			</ul>
			<listing src="xslt-vs-xpath.xsl" line="5-13"/>
		</slide>
		<slide>
			<title>XSLT Executive Summary</title>
			<ul>
				<li>XSLT is an XML-oriented programming language</li>
				<li>XSLT uses XML as its syntax</li>
				<li>XSLT is a weakly typed language</li>
				<li>XSLT is not designed for large programming tasks</li>
				<li>XSLT is the standard language for XML-to-XML transformations</li>
				<li>XSLT is very simple and often too simple</li>
				<li><link href="xslt20-1">XSLT 2.0</link> is much more complex and powerful</li>
			</ul>
		</slide>
		<slide>
			<title>XSLT as a Programming Language</title>
			<ul>
				<li>XSLT is a functional programming language</li>
				<ul>
					<li>fundamentally different from the usual languages</li>
					<li>not important for very simple mapping applications</li>
					<li>important for writing more complex transformations</li>
					<li>hard to get used to for procedurally trained people</li>
				</ul>
				<li>XSLT has built-in behavior for tree traversal</li>
				<ul>
					<li>XPaths allows you to select parts of the document tree</li>
					<li>XSLT's default behavior is to traverse the complete tree</li>
					<li>the idea of <q>default behavior</q> may seem strange</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>XSLT Processing Model</title>
			<img src="xslt-model.png" style="width : 90% ; margin : 2% ; "/>
		</slide>
		<part id="xslt-examples">
			<title>Simple Examples</title>
			<slide>
				<title>My First XSLT</title>
				<ul>
					<li>XSLT uses a simple environment</li>
					<ul>
						<li>all you need is an <em>XSLT processor</em> (<a href="http://www.saxonica.com/">Saxon</a> recommended)</li>
					</ul>
					<li>Some interesting observations</li>
					<ul>
						<li>it is an XML document (using the <a href="http://www.w3.org/TR/xslt#xslt-namespace">XSLT Namespace</a>)</li>
						<li>it contains no visible code (no statements)</li>
						<li>when being applied (i.e., executed), it produces a result</li>
					</ul>
				</ul>
				<listing src="first.xsl"/>
			</slide>
			<slide>
				<title>Why does it Work?</title>
				<ul>
					<li>The <q>text</q> of the document is produced</li>
					<ul>
						<li>technically, it is the concatenation of all text nodes</li>
						<li>this works with all XML input documents</li>
					</ul>
					<li>XSLT by default traverses the document tree</li>
					<ul>
						<li>it copies all text nodes</li>
						<li>it works its way through the document recursively</li>
						<li>this behavior is unusual for a programming language</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>My Second XSLT</title>
				<listing src="second.xsl" line="3-21"/>
			</slide>
			<slide>
				<title>How Mappings Work</title>
				<ul>
					<li>All non-XSLT elements are <em>literal result elements</em></li>
					<ul>
						<li>their content is processed as usual</li>
						<li>they may contain XSLT or literal result elements</li>
					</ul>
					<li>XSLT elements in the stylesheet are instructions</li>
					<ul>
						<li>they are executed and have some predefined behavior</li>
						<li>if they produce results, these go to the result tree as well</li>
					</ul>
					<li>One-template XSLT is a good way to start with XSLT</li>
					<ul>
						<li>avoiding the learning curve associated with <link href="xslt-templates"/></li>
						<li>for easy mapping tasks, this pattern often is sufficient</li>
						<li>for complex tasks, this is the XSLT equivalent of <q>spaghetti code</q></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title><q>Hello World</q> in XSLT</title>
				<ul>
					<li>XSLT always transforms an XML document</li>
					<ul>
						<li>this is hard-coded in the <link href="xslt-processing-model"/></li>
					</ul>
					<li>Simply generating output is impossible</li>
					<ul>
						<li><q>hello world</q> therefore ignores the input</li>
						<li>anything can be the input (including the XSLT itself)</li>
					</ul>
				</ul>
				<listing src="helloworld.xsl"/>
			</slide>
		</part>
		<part>
			<title>XSLT Instructions</title>
			<slide>
				<title>XSLT is Simple</title>
				<ul>
					<li>XSLT has a <a href="http://www.w3.org/TR/xslt#element-syntax-summary">small set of instructions</a></li>
					<ul>
						<li>the language was designed to run in a restricted environment</li>
						<li>the language was designed for a specific task</li>
						<li>much of the language's power lies in XPath</li>
					</ul>
					<li>XPath is the complex part of XSLT</li>
					<ul>
						<li>XPath is a complex high-level language</li>
						<li>it is specialized for the task the language is designed to do</li>
						<li>it can be highly optimized</li>
						<li>writing XPaths often is the most challenging part of XSLT</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-iterations">
				<title>Iterations</title>
				<ul>
					<li>XSLT can only iterate over node sets</li>
					<ul>
						<li>any other problem has to be solved recursively</li>
						<li>iterating over node sets often is what you want to do</li>
					</ul>
					<li>Applying the same code to all of the nodes</li>
					<ul>
						<li>works great if all nodes require the same processing</li>
						<li>is of limited use when processing needs to be conditional</li>
					</ul>
				</ul>
				<listing src="second.xsl" line="11-17"/>
			</slide>
			<slide id="xslt-conditionals">
				<title>Conditional Instructions</title>
				<ul>
					<li>Programming languages usually provide if-then-else</li>
					<ul>
						<li>XSLT has an if-then: <xslte>if</xslte></li>
						<li>and an if-then-(elif-then)*-else: <xslte>choose</xslte></li>
					</ul>
					<li>Simple handling of special cases</li>
					<ul>
						<li>having few and reasonably sized conditionals is ok</li>
						<li>having deeply nested and very long conditionals is a problem</li>
						<li>as in all programming languages, the latter case should user other mechanisms</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>My Second XSLT (II)</title>
				<listing src="second-if.xsl" line="10-22"/>
			</slide>
			<slide>
				<title>My Second XSLT (III)</title>
				<listing src="second-choose.xsl" line="20-38"/>
			</slide>
		</part>
		<part id="xslt-templates">
			<title>Templates</title>
			<slide id="xslt-processing-model">
				<title>XSLT Processing Model</title>
				<img src="xslt-model.png" style="width : 90% ; margin : 2% ; "/>
			</slide>
			<slide>
				<title>Templates as Building Blocks</title>
				<ul>
					<li>Templates are the main unit of code</li>
					<ul>
						<li>the <xslta>match</xslta> attribute defines which nodes are processed by a template</li>
						<li>whenever such a node needs to be processed, the template is executed (<q>applied</q>)</li>
						<li>XPaths are interpreted with the matched node as context</li>
					</ul>
					<li>Templates contain a mix of <link href="xslt-literal"/> and XSLT code</li>
					<ul>
						<li><link href="xslt-literal"/> and text nodes are copied to the result tree</li>
						<li>XSLT elements are executed (depending on their semantics)</li>
						<li><xslte>apply-templates</xslte> plays a special role because it selects nodes to be processed</li>
					</ul>
					<li>The template application process is special</li>
					<ul>
						<li>probably the most challenging aspect when learning the language</li>
						<li>XSLT is much easier to use when understanding the underlying principle</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-algorithm">
				<title>Basic Mechanics</title>
				<ol>
					<li>The <em>source node list</em> contains only the root node</li>
					<li>The result tree is created by inserting the result from processing a node from the source node list</li>
					<li>Processing typically puts more nodes on the source node list</li>
					<li>The process is repeated until the source node list is empty</li>
				</ol>
				<listing src="second.xsl" line="5-15"/>
			</slide>
			<slide>
				<title>Template Selection</title>
				<ul>
					<li>Templates are connected through two statements</li>
					<ul>
						<li><xslte>apply-templates</xslte> selects which are put on the source node list</li>
						<li>the XSLT processor selects the best <xslte>template</xslte> and executes it</li>
					</ul>
					<li>What happens if there is no template?</li>
					<ul>
						<li>templates use <link href="xslt-pattern"/> to specify their applicability</li>
						<li>users may not specify a template for a node they select</li>
						<li>instead of an error, <em>built-in templates</em> are used to handle this situation</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-pattern">
				<title>Patterns</title>
				<ul>
					<li>Patterns are a subset of XPath</li>
					<ul>
						<li>they are used to specify to which nodes certain language constructs apply</li>
						<li>patterns specify a set of conditions on a node</li>
					</ul>
					<li>The specification is short, but hard to understand</li>
					<ul>
						<li><a href="http://www.w3.org/TR/xslt#patterns"><q>A node matches a pattern if the node is a member of the result of evaluating the pattern as an expression with respect to some possible context; the possible contexts are those whose context node is the node being matched or one of its ancestors.</q></a></li>
					</ul>
					<li>Practically, patterns are node tests, node contexts, and predicates</li>
					<ul>
						<li><q><code>*</code></q> matches any element</li>
						<li><q><code>tr</code></q> matches <elem>tr</elem> elements</li>
						<li><q><code>thead/tr</code></q> matches <elem>tr</elem> elements within <elem>thead</elem> elements</li>
						<li><q><code>p[@class='warning']</code></q> matches <elem>p</elem> elements with their <xml>class</xml> set to <code>warning</code></li>
						<li>these mechanisms can be combined (and connected by the union operator <q><code>|</code></q>)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Pattern-Based Processing</title>
				<listing src="people-patterns.xsl" line="10-29"/>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Document-Driven Transformations</title>
				<ul>
					<li>XSLT often works best with <em>document-driven</em> programming</li>
					<li>Imperative programmers are used to control the program flow</li>
					<li>Document-driven processing is a powerful design principle</li>
					<li>Variable document types are better handled by document-driven processing</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xslt-2">
		<title short="XSLT 2">XML Transformations (XSLT) – Part II</title>
		<date>2013-10-23</date>
		<toc class="resources"><a href="http://www-128.ibm.com/developerworks/xml/library/x-tipxsltrun/">XSLT Parameters</a></toc>
		<toc class="abstract">XSLT's template matching mechanism lets the XSLT processor find the <q>best match</q> to process a selected node. XSLT also supports a more traditional way of using templates, where they are called in a way very similar for function calls in most programming languages. Another interesting area of XSLT are variables and parameters, which are used for storing or passing values within XSLT code. One special property of XSLT variables is that they cannot be changed, which is a result of the functional design of the language.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>How to Iterate</title>
			<slide>
				<title>Processing Nodes in XSLT</title>
				<ul>
					<li>XSLT supports two ways of processing nodes</li>
					<ul>
						<li><link href="xslt-iterations"/> loop over a set of selected nodes</li>
						<li><link href="xslt-templates"/> process nodes which have been put on the source node list</li>
					</ul>
					<li>Both mechanisms handle similar situations</li>
					<ul>
						<li>a set of nodes is selected and should be processed</li>
						<li>the code for processing has to available in a code block</li>
						<li><link href="xslt-iterations"/> put this code in the <xslte>for-each</xslte> body</li>
						<li><link href="xslt-templates"/> put this code in a reusable building block</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Homogeneous Processing</title>
				<ul>
					<li><link href="xslt-iterations"/> may lead to less modular code</li>
					<li>If the code has to be reused, they may not be a good solution</li>
					<ul>
						<li><link href="xslt-named-templates"/> may provide some support for reuse</li>
					</ul>
					<li>The selected nodes should require similar processing</li>
					<ul>
						<li>otherwise, the iteration code will contain many conditional statements</li>
					</ul>
					<li>Iterations should be restricted to small units of code</li>
				</ul>
			</slide>
			<slide>
				<title>Heterogeneous Processing</title>
				<ul>
					<li>If the node processing is very different, templates are better</li>
					<ul>
						<li>different templates are written for all nodes being selected</li>
						<li>no conditional code has to be written, selection is done by matching nodes to template patterns</li>
					</ul>
					<li>Templates can be reused</li>
					<ul>
						<li>the nodes appear in different locations and should be processed consistently</li>
						<li>the matching mechanism provides the ideal support for this scenario</li>
					</ul>
					<li>Extensible code should always use templates</li>
					<ul>
						<li>other stylesheets can import an existing stylesheet</li>
						<li>by selectively <q>overwriting</q> templates, the behavior can be customized</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Calling Templates</title>
			<slide>
				<title>Executing Templates</title>
				<ul>
					<li><link href="xslt-templates"/> usually have a <xslta>match</xslta> attribute</li>
					<ul>
						<li>these templates are part of XSLT's special pattern matching processing</li>
					</ul>
					<li>Templates may also be named units of code</li>
					<ul>
						<li>there is nothing special about these templates</li>
						<li>they are being called using a name like regular procedures</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-named-templates">
				<title>Named Templates</title>
				<ul>
					<li><xslte>template</xslte> may also carry a <xslta>name</xslta> attribute</li>
					<li><xslte>call-template</xslte> calls these template by their <xslta>name</xslta></li>
					<li>Named templates have none of the special properties of XSLT template matching</li>
					<ul>
						<li>they are called by their name just like regular procedures</li>
						<li>they do not change the context of XPath evaluation</li>
					</ul>
					<li>Named templates are useful for modularizing code which is not tied to node types</li>
					<ul>
						<li>in most cases, they are called using <link href="xslt-parameters"/></li>
						<li>a typical application is the implementation of a facility for printing messages</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Variables and Parameters</title>
			<slide>
				<title>Programming Language Basics</title>
				<ul>
					<li>Variables in programming languages have different purposes</li>
					<ol>
						<li>defining a <em>name</em> for something so that it can be referred to</li>
						<li>associating this <em>name</em> with a <em>value</em> so that the value can be used</li>
						<li>providing a way to <em>update</em> the variable so that its value changes</li>
					</ol>
					<li>Variables in functional languages cannot change</li>
					<ul>
						<li>they are <em>immutable</em> (often called <em>constants</em> in other languages)</li>
						<li>more specifically, they are <em>dynamic constants</em> (i.e., can be computed at runtime)</li>
						<li>they are defined by giving them a <xpath>name</xpath> and referred to by <xpath>$name</xpath></li>
					</ul>
					<li>Variables in XSLT have no type (no static type checking possible)</li>
					<ul>
						<li>the value that they have is typed</li>
						<li>but a variable may have values of any type</li>
					</ul>
				</ul>
				<pre><![CDATA[<xsl:variable name="sum" select="$op1 + $op2"/>
<xsl:variable name="result" select="$sum * $factor"]]>/></pre>
			</slide>
			<part id="xslt-variables">
				<title>Variables</title>
				<slide>
					<title>Why Variables?</title>
					<ul>
						<li>Reuse of values in different locations</li>
						<ul>
							<li>texts required for the transformation</li>
							<li>facilitates better separation of structure and content</li>
						</ul>
						<pre><![CDATA[<xsl:value-of select="$email-prefix"/> <!- - $email-prefix = 'You have ' - ->
<xsl:value-of select="count(//message)"/>
<xsl:value-of select="$email-suffix"/> <!- - $email-suffix = ' e-mail messages.' - ->]]></pre>
						<li>Using the correct context is essential</li>
						<ul>
							<li>variables cannot be updated</li>
							<li>if they need to be <q>updated</q>, they have to be re-created</li>
						</ul>
						<li>Why are they called <q>variables</q> if they are constants?</li>
						<ul>
							<li>their value varies in different invocations of the context</li>
							<li>they are computed at runtime (dynamic constants) rather than statically</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Scope and Extent</title>
					<ul>
						<li>Variables can be global or local</li>
						<ul>
							<li>global variables are visible in all templates</li>
							<li>local variables are visible in their context (i.e., at <xpath>following-sibling::*/descendant-or-self::*</xpath>)</li>
							<li>local variables are allowed to <em>shadow</em> global (not local) variables</li>
						</ul>
						<li>Variable values may be assigned using the <xslta>select</xslta> attribute</li>
						<ul>
							<li>The XPath's result is the value of the variable</li>
						</ul>
						<li>Variables can contain arbitrary XPath code</li>
						<ul>
							<li>the code is executed in the same way as when constructing the result tree </li>
							<li>the <em>result tree fragment</em> is the value of the variable</li>
							<li>it can be used as a string (<xslte>value-of</xslte>) or as a tree (<xslte>copy-of</xslte>)</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Using Variables</title>
					<listing src="variable-assignment-wrong.xsl" line="4-15"/>
					<listing src="variable-assignment.xsl" line="4-17"/>
				</slide>
			</part>
			<part id="xslt-parameters">
				<title>Parameters</title>
				<slide>
					<title>Parameters vs. Variables</title>
					<ul>
						<li>Parameters are variables with additional semantics</li>
						<ul>
							<li>they are passed to their scope from the outside</li>
							<li>they are available within the scope like a variable (scopes are stylesheets and templates)</li>
							<li>like variables, they cannot be updated (and only global parameters can be shadowed)</li>
						</ul>
						<li>XSLT does not check proper parameter passing</li>
						<ul>
							<li>if a declared parameter is not passed, it gets a default value (specified or <xpath>''</xpath>)</li>
							<li>if a passed parameter is not declared, it is ignored</li>
							<li>like variables, parameters have no type (any value can be passed)</li>
							<li>XSLT's robustness makes it hard to spot programming errors</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Stylesheet Parameters</title>
					<ul>
						<li>Passed to the stylesheet when calling the stylesheet</li>
						<ul>
							<li>the exact way of specifying the parameters depend on the processor and the environment</li>
							<li>the passed values are available in the same way as global variables</li>
							<li>parameter checking has to be done by hand</li>
						</ul>
					</ul>
					<listing src="parameter-test.xsl" line="4-13"/>
				</slide>
				<slide>
					<title>Template Parameters</title>
					<ul>
						<li>Parameters can be passed to templates</li>
						<ul>
							<li>works with <xslte>apply-templates</xslte> and <xslte>call-template</xslte></li>
							<li><xslt>with-param</xslt> elements list the passed parameters</li>
							<li>parameter matching is done by name (there is no particular order to parameters)</li>
						</ul>
						<li>Templates can be programmed as parametrized components</li>
						<ul>
							<li>checking the signature has to be done by hand</li>
							<li><xslt>with-param</xslt> elements list the passed parameters</li>
							<li>parameter matching is done by name (there is no particular order to parameters)</li>
						</ul>
						<li>Parametrized template calls need a lot of markup</li>
						<ul>
							<li>XSLT's XML syntax makes the code hard to read</li>
						</ul>
					</ul>
					<pre>main param start = 1 ; param count = 10 ; {
	loop (0) };
loop param counter ; {
	print $start + $counter ;
	if ( $counter &lt; $count - 1) then 
		loop ($counter + 1) ; }</pre>
				</slide>
				<slide>
					<title>Parameter Passing</title>
					<listing src="parameters.xsl" line="4-21"/>
				</slide>
				<slide>
					<title>Message Facility</title>
					<listing src="message.xsl"/>
				</slide>
			</part>
		</part>
		<part>
			<title>Generating Result Nodes</title>
			<slide id="xslt-literal">
				<title>Literal Result Elements</title>
				<ul>
					<li>Non-XSLT elements are copied to the result tree</li>
					<ul>
						<li>this is the most common way of producing nodes</li>
						<li>in this case, the nodes' names are hard-coded in the stylesheet</li>
					</ul>
					<li>Attributes are also copied to the result tree</li>
					<ul>
						<li>this means the attribute will always be there</li>
						<li>conditional creation of attributes needs other language constructs</li>
					</ul>
				</ul>
			</slide>
			<slide id="xslt-element">
				<title>Producing Nodes Explicitly</title>
				<ul>
					<li>Element nodes can be produced by using <xslt>element</xslt></li>
					<ul>
						<li>the element <xstla>name</xstla> must be specified and can be computed</li>
						<li>additional instructions exist for all node types</li>
					</ul>
				</ul>
				<listing src="uppercaser.xsl" line="3-12"/>
			</slide>
		</part>
		<part>
			<title>Modularizing Stylesheets</title>
			<slide>
				<title>Including and Importing</title>
				<ul>
					<li>XSLT supports two ways of modularizing code</li>
					<ul>
						<li>including simply distributes code across multiple files</li>
						<li>importing creates a dependency and a hierarchy</li>
					</ul>
					<li><xslte>include</xslte> is mainly used for keeping files manageable</li>
					<ul>
						<li>it is used within managed projects</li>
					</ul>
					<li><xslte>import</xslte> is mainly used for reusing code from elsewhere</li>
					<ul>
						<li>it imports reused code and assigns this code a lower precedence</li>
						<li>local instructions can then overwrite (if required) some of the imported code</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Import Precedence</title>
				<img style="margin : 4% ; width : 90% ; " src="xslt-import-precedence.png"/>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XSLT in Practice</title>
				<ul>
					<li>XSLT is a simple programming language</li>
					<li>The processing model needs some time to get used to</li>
					<li>Sometimes the language is really too simple</li>
					<li>If you are really interested in XSLT, learn XSLT 2.0!</li>
					<ul>
						<li>this will also take you 80% along the way to learning XQuery</li>
					</ul>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xslt20-1">
		<title short="XSLT 2.0 1">XML Transformations (XSLT) 2.0 – Part I</title>
		<date>2013-10-28</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xslt20/" title="W3C XSLT 2.0 Specification">XSLT&#160;2.0&#160;Spec</a></toc>
		<toc class="abstract">While <em>XML Transformations (XSLT) 1.0</em> has become a successful programming language widely used for transforming XML documents, its limitations sometimes make it difficult to use XSLT in a good way. An important reason for many of the limitations is the fact that XSLT 1.0 has been designed as a client-side language. Building on XSLT 1.0 and XPath 2.0, <em>XML Transformations (XSLT) 2.0</em> improves the language in a variety of ways.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>XSLT 1.0 Restrictions</title>
			<ul>
				<li>XSLT as a client-side language</li>
				<ul>
					<li>XSLT 1.0 was designed to run in a browser (similar to CSS)</li>
					<li>XSLT today is almost never used as a client-side language</li>
				</ul>
				<li>Processing model geared towards client-side usage</li>
				<ul>
					<li>there always is one input document and one output document</li>
					<li>runtime errors have to be avoided as much as possible</li>
				</ul>
				<li>Data types and XML</li>
				<ul>
					<li>XML is a very weakly <q>typed</q> language (strings, IDs, IDREFs)</li>
					<li>any application data types must be implemented in application code</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>XSLT 2.0 Improvements</title>
			<ul>
				<li>XSLT as a server-side language</li>
				<ul>
					<li>XSLT 2.0 better supports server-side usage</li>
					<li>native XSLT support in browsers might never happen reliably</li>
					<li>shipping XML and transforming it in the browser is not required very often</li>
				</ul>
				<li>Processing model extended to better support server-side usage</li>
				<ul>
					<li>there can be more than one output document</li>
					<li>runtime errors can be a very valuable tool for detecting program errors</li>
				</ul>
				<li><link href="xsd-1">XSD</link> introduces a datatype model for XML</li>
				<ul>
					<li><link href="xsd-simple-types"/> provide a basic vocabulary of datatypes</li>
					<li>many <link href="xpath20">XPath 2.0</link> functions support working with the simple types</li>
					<li><link href="xsd-complex-types"/> allow the definition of structured types</li>
					<li>type checking is supported for simple and complex types</li>
				</ul>
			</ul>
		</slide>
		<part id="xslt20-result-documents">
			<title>Multiple Result Documents</title>
			<slide>
				<title>One XML, Many HTML</title>
				<ul>
					<li>The original model of XSLT 1.0 was a 1:1 mapping of XML and HTML</li>
					<ul>
						<li>a browser retrieves an XML document an generates HTML from it</li>
						<li>this assumed that the granularity of XML is the same as for HTML</li>
					</ul>
					<li>XML documents often represent complex information</li>
					<ul>
						<li>in many cases this is too much information to be displayed on just one HTML page</li>
						<li>typically the complex model of XML is mapped to interlinked HTML</li>
					</ul>
					<li>HTML generated from XML can reflect many different views</li>
					<ul>
						<li>one HTML for each core concept of the XML information model</li>
						<li>indices that make available other HTML through faceted lists</li>
						<li>table of contents using various concepts for listing entries</li>
						<li>alternative representations for core concepts (various dimensions possible)</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Generating HTML Pages</title>
				<listing src="references.xsl" line="4-26"/>
			</slide>
			<part id="xslt-identification">
				<title>Creating Identifiers</title>
				<slide>
					<title>Navigable Hypertext</title>
					<ul>
						<li>Create as many hypertext links as possible</li>
						<ul>
							<li>styling should make sure that hyperlink formatting does not degrade legibility</li>
							<li>use different styles for <em>essential links</em> and <em>ancillary links</em></li>
							<li>ancillary links should not use <a href="http://www.webpagesthatsuck.com/mysterymeatnavigation00.html">mystery meat navigation</a>, but something close</li>
						</ul>
						<li>Purely generated pages get generated names</li>
						<ul>
							<li>table of contents and listings based on various criteria</li>
							<li>index pages for better access to page contents</li>
						</ul>
						<li>Pages representing core concepts should get identifier names</li>
						<ul>
							<li>these identifiers should be stable so that bookmarks do not break</li>
							<li>they can <link href="identifier-reuse">reuse XML identifiers</link>, <link href="identifier-derivation">derive identifiers from content</link>, or <link href="identifier-random">generate random identifiers</link></li>
							<li>a well-defined and stable URI naming policy is important</li>
						</ul>
					</ul>
				</slide>
				<slide id="identifier-reuse">
					<title>Reuse Existing Identifiers</title>
					<ul>
						<li>Many core concepts in XML documents have identifiers</li>
						<ul>
							<li>are these identifiers mandatory?</li>
							<li>are these identifiers a good choice for HTML page names?</li>
							<li>sometimes simple string functions can help to create better identifiers</li>
						</ul>
						<li>URI design is a core part of <a href="../web-fall10/rest">REST</a> and essential to good Web architecture</li>
						<li>True REST design will also allow the creation of new resources</li>
						<ul>
							<li>it is possible to <http>PUT</http> new resources into existing collections</li>
							<li>it is possible to <http>POST</http> new resources to existing collections</li>
							<li><http>PUT</http> and <http>POST</http> are different with regard to the resource name</li>
						</ul>
						<li>These identifiers are a core part of the application data model</li>
					</ul>
				</slide>
				<slide id="identifier-derivation">
					<title>Generate Content-Based Identifiers</title>
					<ul>
						<li>Sometimes more <q>speaking</q> identifiers are required</li>
						<ul>
							<li>easier to understand when looking at the identifier and the URI</li>
							<li>often there is a danger of name clashes</li>
						</ul>
						<li>Blogs often use a combination of the post date and the title</li>
						<ul>
							<li>dates should appear as hierarchical path segments such as <code>2007/10/25</code></li>
							<li>titles are appended by matching the post title to URI syntax (replace and truncate)</li>
							<li>name clashes can only occur on the same day using a very similar title</li>
							<li>date navigation can be used to provide access to date-based index pages</li>
						</ul>
						<li>Generated identifiers should be stable (name clashes should not break them)</li>
					</ul>
				</slide>
				<slide id="identifier-random">
					<title>Generate Random Identifiers</title>
					<ul>
						<li>Sometimes it may not be required or possible to reuse data for identifiers</li>
						<ul>
							<li>this may be true if there is no identifier and no <q>main property</q></li>
							<li>generated identifiers can be design to be very compact</li>
						</ul>
						<li>Random identifiers should use some pseudo-random algorithm</li>
						<ul>
							<li>one possible solution is a fingerprint algorithm such as <a href="http://www.miraclesalad.com/webtools/md5.php">MD5</a></li>
							<li>another solution is a really random solution such as <a href="http://tinyurl.com/">TinyURL</a> or <a href="http://is.gd/">is.gd</a></li>
						</ul>
						<li>It is necessary to keep track of the generated identifiers</li>
						<ul>
							<li>collisions are possible (in particular in case of short random values)</li>
							<li>in case of a collision an alternative identifier must be assigned</li>
						</ul>
					</ul>
				</slide>
			<slide>
				<title>Using Existing Identifiers</title>
				<listing src="references.xsl" line="27-47"/>
			</slide>
			</part>
		</part>
		<part id="xslt20-text-processing">
			<title>Text Processing</title>
			<slide>
				<title>Text Processing in XSLT 1.0</title>
				<ul>
					<li>XPath 1.0 provides a small number of <a href="http://www.w3.org/TR/xpath#section-String-Functions">string functions</a></li>
					<ul>
						<li>the selection of functions is very limited and sometimes restrictive</li>
						<li>more advanced functionality is not available (in particular, no <link href="xslt20-regex"/>)</li>
					</ul>
					<li>Text documents cannot be processed at all in XSLT 1.0</li>
					<ul>
						<li>XSLT 1.0 assumes that valuable input data always is XML</li>
						<li>text is a straightforward extension of the XSLT processing model</li>
						<li>binary data access would require a much bigger change of the language</li>
					</ul>
					<li>XSLT 2.0 extends XSLT to support import <em>and</em> export</li>
					<ul>
						<li>XSLT 1.0 already supports text document as an output format</li>
						<li>XSLT 2.0 now supports text documents as an input format</li>
					</ul>
				</ul>
			</slide>
			<part>
				<title>Accessing Text Documents</title>
				<slide>
					<title>Non-XML in an XML World</title>
					<ul>
						<li>Many tools produce text-based output</li>
						<ul>
							<li>text structures are much simpler and often lossy</li>
							<li>at least <em>some</em> data can be used and reused</li>
						</ul>
						<li><xpath>unparsed-text()</xpath> reads a text-based document</li>
						<ul>
							<li>returns a string containing the complete input document</li>
							<li>optionally, an <xpath>encoding</xpath> can be specified (UTF-8 is the default)</li>
						</ul>
						<li>Text documents often also are <q>structured documents</q></li>
						<ul>
							<li>text uses sentences and paragraphs (empty lines) and maybe other <q>markup</q></li>
							<li>text formats often use commas or semicolon or spaces or tabs for structures</li>
							<li>XSLT 2.0's <link href="xslt20-text-transformation">text transformation features</link> support working with these structures</li>
						</ul>
					</ul>
				</slide>
				<slide id="csv">
					<title short="CSV">Comma-Separated Values (CSV)</title>
					<ul>
						<li><a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a> defines a textual format for <q>spreadsheet data</q></li>
						<li>CSV has been used for a long time, but some of the details were solved differently</li>
						<li>Defining a media type makes it easier for implementations to know what to expect</li>
						<ul>
							<li>the CSV registration not only registers the type, but also defines it</li>
						</ul>
						<li>CSV is not overly complex, but some issues have to be solved</li>
						<ul>
							<li>how to separate lines (CRLF)</li>
							<li>how to end the file (CRLF is allowed but optional)</li>
							<li>are headers allowed (yes, but they are not marked as such)</li>
							<li>may different lines use different numbers of fields (no)</li>
							<li>are spaces significant (yes)</li>
							<li>are quotes significant (no, they are delimiters, so quotes as values must be escaped)</li>
							<li>how to treat fields with CRLF, commas, or quotes (enclose the value in quotes)</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xslt20-text-transformation">
				<title>Transforming Text</title>
				<slide id="xslt20-regex">
					<title>Regular Expressions</title>
					<ul>
						<li><link href="xpath">XPath</link> is great for navigating through an XML tree</li>
						<ul>
							<li>all relevant structures of XML are represented and can be navigated</li>
							<li><link href="xpath">XPath 1.0</link> has some <a href="http://www.w3.org/TR/xpath#section-String-Functions">very basic string functions</a> to work with content</li>
							<li><link href="xpath20">XPath 2.0</link> adds <a href="http://www.w3.org/TR/xpath-functions/#string-functions">many more string functions</a></li>
						</ul>
						<li>XPath 2.0 extends the <a href="http://www.w3.org/TR/xmlschema-2/#regexs">regular expression syntax</a> of <link href="xsd-1">XSD</link></li>
						<ul>
							<li>the usual basic expressions known from many languages and tools</li>
							<li><xpath>^</xpath> and <xpath>$</xpath> for matching beginnings and ends (of strings or lines)</li>
							<li>XPath 2.0 supports <em>reluctant quantifiers</em> (indicated by a <xpath>?</xpath> following a quantifier)</li>
							<li>allows access to sub-expressions (important for selective <xpath>replace()</xpath> of substrings)</li>
							<li>allows back-references within expressions (references captured substrings)</li>
						</ul>
						<li>XPath 2.0 supports regular expressions in three functions</li>
						<ul>
							<li>XSLT 2.0 adds an instruction for <a href="xslt20-string-analyzation">parsing strings</a></li>
						</ul>
					</ul>
				</slide>
				<slide id="xslt20-match-replace">
					<title>Matching &amp; Replacing</title>
					<ul>
						<li><xpath>matches()</xpath> tests whether a string matches a given pattern</li>
						<ul>
							<li>an optional <em>flag</em> allows <a href="http://www.w3.org/TR/xpath-functions/#flags">different processing options</a></li>
							<pre>matches("abracadabra", "bra") ≡ true()</pre>
							<pre>matches("abracadabra", "^a.*a$") ≡ true()</pre>
							<pre>matches("abracadabra", "^bra") ≡ false()</pre>
						</ul>
						<li><xpath>replace()</xpath> selectively replaces parts of the input string</li>
						<ul>
							<li>supports the same flag as the <xpath>matches()</xpath> function</li>
							<pre>replace("abracadabra", "bra", "*") ≡ "a*cada*"</pre>
							<pre>replace("abracadabra", "a.*a", "*") ≡ "*"</pre>
							<pre>replace("abracadabra", "a.*?a", "*") ≡ "*c*bra"</pre>
							<pre>replace("abracadabra", "a(.)", "a$1$1") ≡ "abbraccaddabbra"</pre>
							<pre>replace("abracadabra", "^(.*?)b(.*)$", "$1c$2") ≡ "acracadabra"</pre>
						</ul>
					</ul>
				</slide>
				<slide id="xslt20-tokenizing">
					<title>Tokenizing</title>
					<ul>
						<li><xpath>tokenize()</xpath> turns a string into a sequence of strings</li>
						<ul>
							<li>supports the transition from <em>text structures</em> to the XDM concept of sequences</li>
							<li>supports the same flag as the <xpath>matches()</xpath> and <xpath>replace()</xpath> functions</li>
						</ul>
						<li>Tokenization is based on the concept of pattern-based structures</li>
						<ul>
							<li>input strings are using some recognizable way of separating substrings</li>
							<li>a pattern can be used to find substrings and return them as a sequence</li>
							<pre>tokenize("just plain  text", "\s+") ≡ ( "just", "plain", "text" )</pre>
							<pre>tokenize("1,15,,24,50,", ",") ≡ ( "1", "15", "", "24", "50", "" )</pre>
							<pre>tokenize("HTML &lt;BR> tag&lt;br />soup", "\s*&lt;br\s*/?>\s*", "i") ≡ ("HTML", "tag", "soup")</pre>
						</ul>
					</ul>
				</slide>
				<slide id="xslt20-analyze-string">
					<title>Analyzing Strings</title>
					<ul>
						<li>XPath functions work on a string and return strings or sequences</li>
						<li><xslte>analyze-string</xslte> executes XSLT code for parts of the string</li>
						<ul>
							<li>XSLT code can create elements and/or attributes based on string input</li>
							<li>transforming text in XML often is referred to as <em>up-conversion</em></li>
						</ul>
						<li>two children contain code for handling the parsing process</li>
						<ul>
							<li><xslte>matching-substring</xslte> is executed for each matching part</li>
							<li><xslte>non-matching-substring</xslte> is executed for each non-matching part</li>
							<li>both of these elements are optional</li>
							<li>if two adjacent matching substrings are found, <xslte>matching-substring</xslte> is called twice</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Replacing Characters with Elements</title>
					<ul>
						<li>Replace all newline characters in the abstract element by <elem>br/</elem> elements</li>
					</ul>
					<pre><![CDATA[<xsl:analyze-string select="abstract" regex="\n">
  <xsl:matching-substring>
	<br/>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
	<xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>]]></pre>
				</slide>
				<slide>
					<title>Replacing <q>Character Markup</q></title>
					<ul>
						<li>Turn textual conventions into XML markup</li>
						<ul>
							<li>citations are using <q>[…]</q> for the citation identification</li>
						</ul>
					</ul>
					<pre><![CDATA[<xsl:analyze-string select="body" regex="\[(.*?)\]">
  <xsl:matching-substring>
	<cite><xsl:value-of select="regex-group(1)"/></cite>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
	<xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>]]></pre>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>A Better XSLT</title>
				<ul>
					<li>Multiple result documents can generate Web sites from one XML</li>
					<li>Highly interlinked hypertext can be produced by adding HTML links</li>
					<li>Text processing opens a new possibility for XSLT processing</li>
					<li>Regular expression support allows flexible processing of text documents</li>
					<li>XPath 2.0 and XSLT 2.0 support pattern-based text processing</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xslt20-2">
		<title short="XSLT 2.0 2">XML Transformations (XSLT) 2.0 – Part II</title>
		<date>2013-10-30</date>
		<toc class="resources"><a href="http://www.oreillynet.com/xml/blog/2007/03/reevaluating_xslt_20.html" title="Kurt Cagle O'Reilly Blog">Reevaluating XSLT 2.0</a></toc>
		<toc class="abstract">Many of the new features of XSLT 2.0 have their roots in XPath 2.0 and the underlying new data model of sequences. But some features of XSLT 2.0 really are part of the language itself, such as support for <em>user-defined functions</em>, and the ability to <em>group items</em> and then iterate over these groups. In addition, XSLT now can be used as a <em>typed programming language</em>, which consumes and produces <em>typed trees</em> instead of just well-formed XML trees.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="xslt20-functions">
			<title>User-Defined Functions</title>
			<slide>
				<title>Reusable Code in XPaths</title>
				<ul>
					<li>XSLT 1.0 allows code reuse based on <em>templates</em></li>
					<ul>
						<li><link href="xslt-named-templates"/> can be called by name like subroutines</li>
						<li>they can only be called in XSLT code, not in an XPath</li>
					</ul>
					<li>User-defined functions in XPaths support modular code</li>
					<ul>
						<li>any code that produces a sequence of items</li>
						<li>input parameters can be specified (as for templates and stylesheets)</li>
						<li>the function is called using regular XPath function call syntax</li>
					</ul>
					<li>User-defined functions always must use a namespace</li>
					<ul>
						<li>the function definition must use an existing namespace prefix</li>
						<li>the function call must use the same namespace for the function name</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Function Definition and Call</title>
				<listing src="references.xsl" line="54-57"/>
				<listing src="references.xsl" line="11-23"/>
			</slide>
		</part>
		<part id="xslt20-grouping">
			<title>Grouping</title>
			<slide>
				<title>Aggregating Items</title>
				<ul>
					<li>Lists of items often have to be grouped by some value</li>
					<ul>
						<li>addresses may be grouped by initial letter or city or ZIP code</li>
						<li>sports events may be grouped by location or team or season</li>
						<li>restaurants may be grouped by kitchen or location or quality</li>
					</ul>
					<li>Grouping needs to <em>identify</em> and <em>build</em> groups</li>
					<ul>
						<li>for small datasets, implementation issues are not really relevant</li>
						<li>for large datasets, performance is greatly affected by the implementation</li>
					</ul>
					<li>XSLT 1.0 has no support for grouping</li>
					<ul>
						<li>XPath axes can be used to find the first member of each group</li>
						<pre>contact[not(surname = preceding-sibling::contact/surname)]</pre>
						<li>this expression can become very expensive to evaluate for large datasets</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Grouping and Iterating over Groups</title>
				<listing src="references.xsl" line="27-47"/>
			</slide>
		</part>
		<part id="xslt20-typing">
			<title>Typed Programming</title>
			<slide>
				<title>XDM and XPath 2.0 Support Types</title>
				<ul>
					<li>Useful for predefined types such as <xsdtype>date</xsdtype> and <xsdtype>dateTime</xsdtype></li>
					<li>When working with DTDs, values must be explicitly cast</li>
					<li>When working with <link href="xsd-1">XSD</link>, types are inferred from the schema</li>
					<ul>
						<li>documents are validated before they are processed</li>
						<li>validation turns the XML tree into a <em>type-annotated tree</em></li>
						<li>XSLT 2.0 has access to the type information and treats nodes as typed</li>
					</ul>
					<li>Schema-aware XSLT allows type control for output documents</li>
					<ul>
						<li><xslte>result-document</xslte> and <xslte>document</xslte> create new document trees</li>
						<li><xslta>validation</xslta> and <xslta>type</xslta> control validation for these trees</li>
						<li>only schema-aware XSLT 2.0 processors support these attributes</li>
					</ul>
				</ul>
			</slide>
			<part id="xslt20-simple-types">
				<title>Typed Nodes</title>
				<slide>
					<title>XSD Simple Types</title>
					<ul>
						<li><link href="xsd-simple-types"/> are used to type non-markup values</li>
						<ul>
							<li>mostly <em>atomic types</em> which describe the content of an element or attribute</li>
							<li><em>union types</em> and <em>list types</em> describe alternative or repeatable types</li>
						</ul>
						<li>Working with simple types is supported in any XSLT 2.0 processor</li>
						<ul>
							<li>the basic XSD datatypes are part of XDM and always available</li>
							<pre>xs:date( if ( $i castable as xs:date ) then $i else '2000-01-01' )</pre>
						</ul>
						<li>Working with user-defined simple types is a different story</li>
						<ul>
							<li><link href="xsd-simple-type-restriction"/> is used to derive new simple types</li>
							<li>users can build their own specialized type library</li>
							<li>such a library is a schema and requires a schema-aware XSLT 2.0 processor</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xslt20-complex-types">
				<title>Typed Trees</title>
				<slide>
					<title>XSD Complex Types</title>
					<ul>
						<li><link href="xsd-complex-types"/> are used to type markup structures</li>
						<ul>
							<li>they are always associated with element nodes</li>
							<li>they describe the content model and allowed attributes for that type</li>
						</ul>
						<li>Working with complex types very much depends on the schema design</li>
						<ul>
							<li>if the schema tries to reflect the model in the types, it may be useful</li>
							<li>if the schema has been generated by some tool, types are not very relevant</li>
						</ul>
						<li>A more interesting idea would be to actually inspect a type</li>
						<ul>
							<li>upon finding a type, find out what attributes are optional but not required</li>
							<li>this would require access not only to the <em>type name</em>, but to the <em>type definition</em></li>
							<li>this is a very interesting research issue, but not yet possible in XSLT 2.0</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>Consider Upgrading</title>
				<ul>
					<li>Going from XSLT 1.0 to 2.0 supports more data types</li>
					<li>Going to schema-aware XSLT 2.0 supports typed documents</li>
					<li>For serious programming, type checking is very useful</li>
					<li>Start using XSLT 2.0 as soon as possible</li>
					<li>Start using schema-aware XSLT 2.0 as soon as required</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="rest">
		<title short="REST">Representational State Transfer (REST)</title>
		<date>2013-11-13</date>
		<toc class="resources"><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" title="Roy Thomas Fielding, 'Architectural Styles and the Design of Network-based Software Architectures', Ph.D. Thesis, University of California, Irvine, Irvine, California, 2000">Fielding&#160;Dissertation</a>&#160;· <a href="http://portal.acm.org/citation.cfm?doid=337180.337228" title="Roy Thomas Fielding and Richard N. Taylor, 'Principled Design of the Modern Web Architecture', ACM Transactions on Internet Technology, 2(2):115-150, May 2002">REST&#160;Paper</a></toc>
		<toc class="abstract"><em>Representational State Transfer (REST)</em> is defined as an <em>architectural style</em>, which means that it is not a concrete systems architecture, but instead a set of constraints that are applied when designing a systems architecture. We briefly discuss these constraints, but then focus on explaining how the Web is one such systems architecture that implements REST. In particular, the mechanisms of the <em>Uniform Resource Identifiers (URIs)</em>, the <em>Hypertext Transfer Protocol (HTTP)</em>, media types, and markup languages such as the <em>Hypertext Markup Language (HTML)</em> and the <em>Extensible Markup Language (XML)</em>. We also introduce <em>Atom</em> and the <em>Atom Publishing Protocol (AtomPub)</em> as two established ways on how RESTful services are already provided and used on today's Web.</toc>
		<slide>
			<title>Abstract</title>
            <p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="rest-definition">
			<title>REST: The Definition</title>
			<slide>
				<title>The REST Architectural Style</title>
				<ul>
					<li>A set of constraints that inform an architecture</li>
				</ul>
				<ol>
					<li><link href="identification-constraint"/></li>
					<li><link href="interface-constraint"/></li>
					<li><link href="self-describing-constraint"/></li>
					<li><link href="hypermedia-constraint"/></li>
					<li><link href="stateless-constraint"/></li>
				</ol>
				<ul>
					<li>Claims: scalability, mashup-ability, usability, accessibility</li>
				</ul>
			</slide>
			<slide id="identification-constraint">
				<title>Resource Identification</title>
				<ul>
					<li>Name everything that you want to talk about</li>
					<li><q>Thing</q> in this case should refer to <em>anything</em></li>
					<ul>
						<li><em>products</em> in an online shop</li>
						<li><em>categories</em> that are used for grouping products</li>
						<li><em>customers</em> that are expected to buy products</li>
						<li><em>shopping carts</em> where customers collect products</li>
					</ul>
					<li><em>Application state</em> also is represented as a resource</li>
					<ul>
						<li><em>next</em> links on multi-page submission processes</li>
						<li><em>paged results</em> with URIs identifying following pages</li>
					</ul>
				</ul>
			</slide>
			<slide id="interface-constraint">
				<title>Uniform Interface</title>
				<ul>
					<li>The same small set of operations applies to <link href="identification-constraint">everything</link></li>
					<li>A small set of <em>verbs</em> applied to a large set of <em>nouns</em></li>
						<li>verbs are universal and not invented on a per-application base</li>
						<li>if many applications need new verbs, the uniform interface can be extended</li>
						<li>natural language works in the same way (new verbs rarely enter language)</li>
					<li>Identify operations that are candidates for optimization</li>
					<ul>
						<li><http>GET</http> and <http>HEAD</http> are <em>safe operations</em></li>
						<li><http>PUT</http> and <http>DELETE</http> are <em>idempotent operations</em></li>
						<li><http>POST</http> is the catch-all and can have side-effects</li>
					</ul>
					<li>Build functionality based on useful properties of these operations</li>
				</ul>
			</slide>
			<slide id="self-describing-constraint">
				<title>Self-Describing Messages</title>
				<ul>
					<li>Resources are abstract entities (they cannot be used <em>per se</em>)</li>
					<ul>
						<li><link href="identification-constraint"/> guarantees that they are clearly identified</li>
						<li>they are accessed through a <link href="interface-constraint"/></li>
					</ul>
					<li>Resources are accessed using <em>resource representations</em></li>
					<ul>
						<li>resource representations are sufficient to represent a resource</li>
						<li>it is communicated which kind of representation is used</li>
						<li>representation formats can be negotiated between peers</li>
					</ul>
					<li>Resource representations can be based on different constraints</li>
					<ul>
						<li>XML and JSON can represent the same model for different users</li>
						<li>whatever the representation is, it must <link href="hypermedia-constraint"> support links</link></li>
					</ul>
				</ul>
			</slide>
			<slide id="hypermedia-constraint">
				<title>Hypermedia Driving Application State</title>
				<ul>
					<li><link href="self-describing-constraint">Resource representations</link> contain links to <link href="identification-constraint">identified resources</link></li>
					<li>Resources and state can be used by navigating links</li>
					<ul>
						<li>links make interconnected resources navigable</li>
						<li>without navigation, identifying new resources is service-specific</li>
					</ul>
					<li>RESTful applications <em>navigate</em> instead of <em>calling</em></li>
					<ul>
						<li><link href="self-describing-constraint">representations</link> contain information about possible traversals</li>
						<li>the application navigates to the next resource depending on link semantics</li>
						<li>navigation can be delegated since all links use <link href="identification-constraint">identifiers</link></li>
					</ul>
				</ul>
			</slide>
			<slide id="stateless-constraint">
				<title>Stateless Interactions</title>
				<ul>
					<li>This constraint does not say <q>Stateless Applications</q>!</li>
					<ul>
						<li>for many RESTful applications, state is an essential part</li>
						<li>the idea of REST is to avoid long-lasting transactions <em>in applications</em></li>
					</ul>
					<li>Statelessness means to move state to clients or resources</li>
					<ul>
						<li>the most important consequence: avoid state in server-side applications</li>
					</ul>
					<li><em>Resource state</em> is managed on the server</li>
					<ul>
						<li>it is the same for every client working with the service</li>
						<li>when a client changes resource state other clients see this change as well</li>
					</ul>
					<li><em>Client state</em> is managed on the client</li>
					<ul>
						<li>it is specific for a client and thus has to be maintained by each client</li>
						<li>it may affect <em>access</em> to server resources, but not the resources themselves</li>
					</ul>
					<li><em>Security issues</em> usually are important with client state</li>
					<ul>
						<li>clients can (try to) cheat by lying about their state</li>
						<li>keeping client state on the server is expensive (but may be worth the price)</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part id="web-arch">
			<title>Web Architecture</title>
			<slide>
				<title>What is the Web?</title>
				<ul>
					<li>Web = URI + HTTP + ( HTML | XML )</li>
					<li>RESTful Web uses HTTP methods as the uniform interface</li>
					<ul>
						<li>non-RESTful Web uses <http>GET</http>/<http>POST</http> and tunneled RPC calls</li>
						<li>a <q>different RESTful Web</q> uses <em>Web Distributed Authoring and Versioning (WebDAV)</em></li>
					</ul>
					<li>Imagine your application being used in <q>10 browsers</q></li>
					<ul>
						<li>resources to interact with should be <link href="identification-constraint">identified</link> and <link href="hypermedia-constraint">linked</link></li>
						<li>a user's preferred font size could be modeled as client state</li>
						<li>what about an access count associated with an API key?</li>
					</ul>
					<li>Imagine your application being used in <q>10 browser tabs</q></li>
					<ul>
						<li>no difference as long as client state is representation-based</li>
						<li>cookies are shared across browser windows (different <q>client scope</q>)</li>
					</ul>
				</ul>
			</slide>
			<part id="uri">
				<title short="URI">Uniform Resource Identifier (URI)</title>
				<slide>
					<title>Identifying Resources on the Web</title>
					<ul>
						<li>Essential for implementing a <link href="identification-constraint"/></li>
						<li>URIs are human-readable universal identifiers for <q>stuff</q></li>
						<ul>
							<li>many identification schemes are not human-readable (binary or hex strings)</li>
							<li>many RPC-based systems do not have universally identified objects</li>
						</ul>
						<li>Making every thing a universally unique identified thing is important</li>
						<ul>
							<li>it removes the necessity to <em>scope</em> non-universal identifiers</li>
							<li>it allows to talk about all things in exactly the same way</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>URI Schemes</title>
					<pre>URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]</pre>
					<ul>
						<li>URIs in their general case are very simple</li>
						<ul>
							<li>the scheme identifies how resources are identified</li>
							<li>the identification may be hierarchical or non-hierarchical</li>
						</ul>
						<li>Many URI schemes are hierarchical</li>
						<ul>
							<li>it is then possible to use relative URIs such as in <elem>a href="../"</elem></li>
							<li>the slash character is not just a character, in URIs it has semantics</li>
						</ul>
					</ul>
					<blockquote>[…] the URI syntax is a federated and extensible naming system wherein each scheme's specification may further restrict the syntax and semantics of identifiers using that scheme.</blockquote>
					<p class="quotenote"><a href="http://tools.ietf.org/html/rfc3986"><q>Uniform Resource Identifier (URI): Generic Syntax</q>, RFC 3986, January 2005</a></p>
				</slide>
			</part>
			<part id="http">
				<title short="http">Hypertext Transfer Protocol (HTTP)</title>
				<slide>
					<title>How RESTful Applications Talk</title>
					<ul>
						<li>Essential for implementing a <link href="interface-constraint"/></li>
						<ul>
							<li>HTTP defines a small set of methods for acting on URI-identified resources</li>
						</ul>
						<li>Misusing HTTP turns application into non-RESTful applications</li>
						<ul>
							<li>they lose the capability to be used just by adhering to REST principles</li>
							<li>it's a bad sign when you think you need an interface description language</li>
						</ul>
						<li>Extending HTTP turns applications into more specialized RESTful applications</li>
						<ul>
							<li>may be appropriate when more operations are required</li>
							<li>seriously reduces the number of potential clients</li>
						</ul>
					</ul>
				</slide>
				<slide id="http-methods">
					<title>HTTP Methods</title>
					<ul>
						<li><em>Safe methods</em> can be ignored or repeated without side-effects</li>
						<ul>
							<li>arithmetically safe: <code>41 × 1 × 1 × 1 × 1 …</code></li>
							<li>in practice, <q>without side-effects</q> means <q>without relevant side-effects</q></li>
						</ul>
						<li><em>Idempotent methods</em> can be repeated without side-effects</li>
						<ul>
							<li>arithmetically idempotent: <code>41 × 0 × 0 × 0 × 0 …</code></li>
							<li>in practice, <q>without side-effects</q> means <q>without relevant side-effects</q></li>
						</ul>
						<li>Unsafe and non-idempotent methods should be treated with care</li>
						<li>HTTP has two main <em>safe methods</em>: <http>GET HEAD</http></li>
						<li>HTTP has two main <em>idempotent methods</em>: <http>PUT DELETE</http></li>
						<li>HTTP has one main <em>overload method</em>: <http>POST</http></li>
					</ul>
				</slide>
				<slide id="cookies">
					<title>Cookies</title>
					<ul>
						<li>Cookies are <em>client site state bound to a domain</em></li>
						<ul>
							<li>they are convenient because they work <em>without having to use a representation</em></li>
							<li>they are inconvenient because they are <em>not embedded in representations</em></li>
						</ul>
						<li>Cookies are managed by the client</li>
						<ul>
							<li>they are shared across browser tabs</li>
							<li>they are not shared across browsers used by the same user</li>
							<li>essentially, the <em>client</em> model of cookies is a bit outdated</li>
						</ul>
						<li>Two major things to look out for when using cookies:</li>
						<ol>
							<li><em>session IDs</em> are <em>application state</em> (i.e., non-resource state)</li>
							<li>cookies break the back button (requests contain a <q>URI/cookie</q> combo)</li>
						</ol>
						<li>The ideal RESTful cookie is never sent to the server</li>
						<ul>
							<li>cookies as <em>persistent data storage on the client</em></li>
							<li>interactions with the server are only using URIs and representations</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part id="representations">
			<title>Representations</title>
			<part id="documents">
				<title>Structured Documents</title>
				<slide>
					<title>What is identified by a URI?</title>
					<ul>
						<li>Essential for implementing <link href="self-describing-constraint"/></li>
						<ul>
							<li>also should provide support for <link href="hypermedia-constraint"/></li>
						</ul>
						<li><link href="identification-constraint"/> only talks about an <em>abstract resource</em></li>
						<ul>
							<li>resources are never exchanged or otherwise processed directly</li>
							<li>all interactions use <em>resource representations</em></li>
						</ul>
						<li>Representations depend on various factors</li>
						<ul>
							<li>the nature of the resource</li>
							<li>the capabilities of the server</li>
							<li>the capabilities or the communications medium</li>
							<li>the capabilities of the client</li>
							<li>requirements and constraints from the application scenario</li>
							<li>negotiations to figure out the <q>best</q> representation</li>
						</ul>
						<li>Representations are identified by <em>media type</em></li>
					</ul>
				</slide>
				<slide id="xml">
					<title short="XML">Extensible Markup Language (XML)</title>
					<ul>
						<li>The language that started it all</li>
						<ul>
							<li>created as a streamlined version of SGML</li>
							<li>took over as the first universal language for structured data</li>
						</ul>
						<li>XML is a metalanguage (a language for representing languages)</li>
						<ul>
							<li>many domain-specific languages are defined as XML vocabularies</li>
						</ul>
						<li>XML is only syntax and has almost zero semantics</li>
						<ul>
							<li>very minimal built-in semantics (language identification, IDs, relative URIs)</li>
							<li>semantics are entirely left to the XML vocabularies</li>
						</ul>
						<li>XML is built around a tree model</li>
						<ul>
							<li>each XML document is a tree and thus limited in structure</li>
							<li>RESTful XML introduces hypermedia to turn XML data into a graph</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title short="JSON">JavaScript Object Notation (JSON)</title>
					<ul>
						<li>The <code>XMLHttpRequest</code> API has been built for requesting XML via HTTP</li>
						<ul>
							<li>this is useful because XML is the most popular data format</li>
							<li>all requested data has to be processed by using XML access methods in JavaScript</li>
						</ul>
						<li>JavaScript does not have XML as its internal data model</li>
						<ul>
							<li>the XML received via <code>XMLHttpRequest</code> has to be parsed into a DOM tree</li>
							<li>DOM access in JavaScript is inconvenient for complex operations</li>
							<li>alternatively, the XML can be mapped to JavaScript objects (also requires parsing)</li>
						</ul>
						<li><link href="json"/> encodes data as JavaScript objects</li>
						<ul>
							<li>more efficient for the consumer if the consumer is written in JavaScript</li>
							<li>this turns the generally usable XML service into a JavaScript-oriented service</li>
							<li>for large-scale applications, it might make sense to provide XML and JSON</li>
							<li>this can be negotiated with <em>HTTP content negotiation</em></li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>JSON Example</title>
					<listing src="menu.xml"/>
					<listing src="menu.json"/>
				</slide>
				<slide>
					<title>Atom</title>
					<ul>
						<li>A language for representing <em>syndication feeds</em></li>
						<li>Much more modest in its goal than <link href="xml">XML</link> or <link href="rdf">RDF</link></li>
						<ul>
							<li>models feeds as a sets of entries with associated metadata</li>
							<li>uses an XML vocabulary for representing the data model</li>
							<li>uses <em>links</em> for expressing relationships in the data model</li>
						</ul>
						<li>Will be discussed in detail as <link href="atom">a good foundation for REST</link></li>
					</ul>
				</slide>
			</part>
			<part id="links">
				<title>Linked Documents</title>
				<slide>
					<title>Making Resources Navigable</title>
					<ul>
						<li>Essential for using <link href="hypermedia-constraint"/></li>
						<li>RPC-oriented systems need to expose the available functions</li>
						<ul>
							<li>functions are essential for interacting with a service</li>
							<li>introspection or interface descriptions make functions discoverable</li>
						</ul>
						<li>RESTful systems use a <link href="interface-constraint"/></li>
						<ul>
							<li>no need to learn about functions</li>
							<li>but how to find resources?</li>
						</ul>
						<ol>
							<li>find them by following links from other resources</li>
							<li>learn about them by using <link href="uri-templates"/></li>
							<li>understand them by recognizing representations</li>
						</ol>
					</ul>
				</slide>
				<slide id="uri-templates">
					<title>URI Templates</title>
					<ul>
						<li>REST does not care about URI details</li>
						<li>Apart from the <uri>scheme</uri>, URIs should be semantically opaque</li>
						<ul>
							<li>media types should not guessed by URI (breaks content negotiation)</li>
							<li>semantics should not be inferred from inspecting URIs</li>
							<li>URIs should not be guessed based on previously encountered URIs</li>
						</ul>
						<li><q>URI hacking</q> on the Web works and can be useful</li>
						<ul>
							<li>Firefox <a href="http://dret.typepad.com/dretblog/2008/07/go-up.html">Go Up</a> allows easy navigation up one level</li>
							<li>good URIs and bad UIs sometimes turn the address bar into a useful UI</li>
						</ul>
						<li>Technically speaking, URI templates are not required by REST</li>
						<ul>
							<li>practically speaking, URI templates are a useful best practice</li>
							<li>all URI navigable resources should also be navigable using representations</li>
						</ul>
					</ul>
				</slide>
			</part>
		</part>
		<part id="state">
			<title>State</title>
			<slide>
				<title>State Management on the Web</title>
				<ul>
					<li>Essential for supporting <link href="stateless-constraint"/></li>
					<li><link href="cookies"/> are a frequently used mechanism for managing state</li>
					<ul>
						<li>in many cases used for maintaining session state (login/logout)</li>
						<li>more convenient than having to embed the state in every representation</li>
						<li>some Web frameworks switch automatically between cookies and URI rewriting</li>
					</ul>
					<li>Cookies have two interesting client-side side-effects</li>
					<ul>
						<li>they are stored persistently independent from any representation</li>
						<li>they are <q>shared state</q> within the context of one browser</li>
					</ul>
					<li>Session ID cookies require expensive server-side tracking</li>
					<ul>
						<li>not associated with any resource and thus potentially global</li>
						<li>load-balancing must be cookie-sensitive or cookies must be global</li>
					</ul>
					<li><em>Resource-based state</em> allows RESTful service extensions</li>
				</ul>
			</slide>
			<slide>
				<title>State in HTML or HTTP</title>
				<img style="width : 90% ; margin : 2% ; " src="web-app-client-state.png" title="State in HTML or HTTP"/>
			</slide>
			<slide>
				<title>State in the Server Application</title>
				<img style="width : 90% ; margin : 2% ; " src="web-app-server-state.png" title="State in the Server Application"/>
			</slide>
			<slide>
				<title>State as a Resource</title>
				<img style="width : 90% ; margin : 2% ; " src="web-app-resource-state.png" title="State as a Resource"/>
			</slide>
			<slide>
				<title>Stateless Shopping</title>
				<ul>
					<li>Typical <q>session scenarios</q> can be <a href="http://www.peej.co.uk/articles/no-sessions.html">mapped to resources</a></li>
					<ul>
						<li>Client: Show me your products</li>
						<li>Server: Here's a list of all the products</li>
						<li>Client: I'd like to buy 1 of http://ex.org/product/X, I am "John"/"Password"</li>
						<li>Server: I've added 1 of http://ex.org/product/X to http://ex.org/users/john/basket</li>
						<li>Client: I'd like to buy 1 of http://ex.org/product/Y, I am "John"/"Password"</li>
						<li>Server: I've added 1 of http://ex.org/product/Y to http://ex.org/users/john/basket</li>
						<li>Client: I don't want http://ex.org/product/X, remove it, I am "John"/"Password"</li>
						<li>Server: I've removed http://ex.org/product/X to http://ex.org/users/john/basket</li>
						<li>Client: Okay I'm done, username/password is "John"/"Password"</li>
						<li>Server: Here is the total cost of the items in http://ex.org/users/john/basket</li>
					</ul>
					<li>This is more than just renaming <q>session</q> to <q>resource</q></li>
					<ul>
						<li>all relevant data is stored persistently on the server</li>
						<li>the shopping cart's URI can be used by other services for working with its contents</li>
						<li>instead of <em>hiding the cart in the session</em>, it is <em>exposed as a resource</em></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Reusing Resources</title>
				<img style="width : 90% ; margin : 2% ; " src="web-app-reusing-resource.png" title="Reusing Resources"/>
			</slide>
		</part>
		<slide>
			<title>Conclusions</title>
			<ul>
				<li>REST is simple to learn and use</li>
				<li>Unlearning RPC in most cases is the hardest part</li>
				<ul>
					<li>OO is all about identifying classes and methods</li>
					<li>distributed systems very often are built around RPC models</li>
					<li>many classical IT architectures are RPC-centric by design</li>
				</ul>
				<li>REST and RPC do not mix</li>
				<ul>
					<li>resource orientation ↔ function orientation</li>
					<li>cooperation ↔ integration</li>
					<li>openly distributed ↔ hiding distribution</li>
					<li>coarse-grained ↔ fine-grained</li>
					<li>complexity in resources formats ↔ complexity in function set</li>
				</ul>
			</ul>
		</slide>
	</presentation>
	<presentation id="atom">
		<title short="Atom">Atom Syndication Format</title>
		<date>2013-11-18</date>
		<toc class="resources"><a href="http://tools.ietf.org/html/rfc4287" title="Atom RFC">Atom&#160;Spec</a>&#160;· <a href="http://tools.ietf.org/html/rfc5032" title="Atom Publishing Protocol (AtomPub) RFC">AtomPub&#160;Spec</a>&#160;· <a href="http://validator.w3.org/feed/" title="W3C RSS/Atom Feed Validator">Feed&#160;Validator</a></toc>
		<toc class="abstract">REST's level of abstraction and its simplicity as a small set of constraints can make it hard to get a grasp on how it can be applied for real-world projects. This presentations introduces <em>real-world REST</em> by looking at how REST can be used by reusing existing RESTful designs in terms of representations and interaction protocols; <em>Atom</em> and the <em>Atom Publishing Protocol (AtomPub)</em> are used as examples for existing RESTful designs. In addition, we take a brief look at how to go beyond using these <q>canned REST</q> approaches, and how existing programming framework provide support for designing and implementing RESTful services.</toc>
		<slide>
			<title>Abstract</title>
            <p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide id="snowflake">
			<title>Precious Snowflakes</title>
			<img src="snowflakes.jpg" style="float : right ; width : 25% ; margin : 0.5em 1em 1em 1em ; "/>
			<ul>
				<li>Many applications are not as unique as you might think</li>
				<ul>
					<li>reusing design patterns and even technologies is a good idea</li>
					<li>avoiding reuse usually should be justified by good reasons</li>
				</ul>
				<li>Take the Web's HTML as an inspiring example</li>
				<ul>
					<li>HTML is not all that great as a document format</li>
					<li>it was good enough as a container for a lot of useful content</li>
					<li>the <em>network effect</em> far outweighs its <em>functional shortcomings</em></li>
					<li>could you imagine a Web based on PDF or Word?</li>
				</ul>
				<li>Simplicity and wide applicability are valuable</li>
				<ul>
					<li><em>simplicity</em> means a lower barrier to entry</li>
					<li><em>wide applicability</em> means higher chances to create network effects</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>Feeds!</title>
			<img src="feedbot.jpg" style="float : right ; width : 25% ; margin : 0.5em 1em 1em 1em ; " href="http://www.flickr.com/photos/comingupforair/432964499/"/>
			<ul>
				<li>Information dissemination is a complex and varied problem</li>
				<li>Feeds look at all these problems with a simple approach</li>
				<ul>
					<li>the simple approach lacks some sophistication/specialization</li>
					<li>less specialization means wider applicability</li>
					<li>wider applicability means bigger network effects</li>
					<li>pull-based syndication is loosely coupled and scalable</li>
				</ul>
				<li>Some claim that pull publishing is bad and <em>Publish/Subscribe (PubSub)</em> is good</li>
				<ul>
					<li>there is little proof that this is more than just a claim</li>
					<li>scalable PubSub is expensive to implement (but still may make sense)</li>
					<li><em href="http://code.google.com/p/pubsubhubbub/">PubSubHubbub (PuSH)</em> implements feed-based PubSub</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>Syndication</title>
			<ul>
				<li>Atom is a format and also <a href="http://dret.typepad.com/dretblog/atom-landscape.html">an evolving landscape</a></li>
				<ul>
					<li><link href="atom"/>, the feed format (<a href="http://tools.ietf.org/html/rfc4287">RFC 4287</a>)</li>
					<li><link href="atompub"/>, write access to Atom-oriented collections (<a href="http://tools.ietf.org/html/rfc5023">RFC 5023</a>)</li>
					<li>support for threaded discussions in feeds (<a href="http://tools.ietf.org/html/rfc4685">RFC 4685</a>)</li>
					<li>feed licensing (<a href="http://tools.ietf.org/html/rfc4946">RFC 4946</a>)</li>
					<li>feed paging and archiving (<a href="http://tools.ietf.org/html/rfc5005">RFC 5005</a>)</li>
					<li><a href="http://dret.typepad.com/dretblog/atom-landscape.html">many other ongoing developments</a></li>
				</ul>
				<li>A landscape of RESTful interactions with <q>collections of resources</q></li>
			</ul>
		</slide>
		<part id="atom-format">
			<title>Atom</title>
			<slide>
				<title>Atom History</title>
				<img src="atom-logo.png" href="http://atompub.org/" style="float : right ; width : 20% ; margin-top : 0.5em ; margin-right : 2em ; "/>
				<ul>
					<li>RSS's shortcomings were very apparent and could not be fixed</li>
					<li>In mid-2003, discussions started about an improved format</li>
					<li>It also became apparent that the format should have a protocol</li>
					<li>Atom 0.3 was released in December 2003 but had no formal home</li>
					<li>IETF was chosen as the new home with a working group in June 2004</li>
					<li><a href="http://tools.ietf.org/html/rfc4287">RFC 4287</a> was published in December 2005</li>
					<li><link href="atompub">AtomPub</link> has been published as <a href="http://tools.ietf.org/html/rfc5032">RFC 5032</a> in October 2007</li>
				</ul>
			</slide>
			<slide>
				<title>Atom vs. RSS</title>
				<ul>
					<li>Standardized by the IETF (well-defined process)</li>
					<li>Classification of entries (user-defined categories)</li>
					<li>More XML-like markup design (more nesting)</li>
					<li>Namespaces are used and supported as standard mechanism</li>
					<li>Atom feeds <em>must</em> be well-formed XML (there even <a href="http://atompub.org/2005/08/17/atom.rnc" title="Atom RELAX NG Schema">is a schema</a>)</li>
					<li>Interpretation of content is well-defined (various content types)</li>
					<li>Support for <xml>xml:lang</xml> and <xml>xml:base</xml></li>
				</ul>
			</slide>
			<slide>
				<title>Atom Example</title>
				<listing src="atom.xml"/>
			</slide>
			<slide>
				<title>Atom Content</title>
				<ul>
					<li>RSS had no safe way of finding out what an entry's content is</li>
					<ul>
						<li>this led to different implementations being <q>smart</q> about what the RSS author really wanted</li>
						<li>one of Atom's main goals was to improve this in a well-defined way</li>
						<li>Atom allows escaped markup (the only way to include non-XML HTML in an XML format)</li>
					</ul>
					<li>Each <elem>content</elem> element should have a <atom>type</atom> (the default is <atom>text</atom>)</li>
					<li>Atom's content interpretation algorithm (use first applicable rule):</li>
					<ol>
						<li>if <atom>type</atom> is <atom>text</atom>, no child elements are allowed (plain text content)</li>
						<li>if <atom>type</atom> is <atom>html</atom> then RSS's method of escaped markup is used</li>
						<li>if <atom>type</atom> is <atom>xhtml</atom> then there must be an <elem>div</elem> containing XHTML markup</li>
						<li>if <atom>type</atom> is an XML media type then the content should be treated as this type</li>
						<li>if <atom>type</atom> starts with <atom>text/</atom> then no child elements are allowed</li>
						<li>for all other values, the content must be an base64-encoded entity of the specified MIME type</li>
					</ol>
				</ul>
			</slide>
			<slide>
				<title>Atom Content Examples</title>
				<pre href="http://www.xml.com/lpt/a/1633"><![CDATA[<content type="xhtml">
  <div xmlns="http://www.w3.org/1999/xhtml">
    One <strong>bold</strong> foot forward
  </div>
</content>]]></pre>
				<pre href="http://www.xml.com/lpt/a/1633"><![CDATA[<content>The "atom:content" element either contains or links to the content of the entry. The content of atom:content is Language-Sensitive.</content>]]></pre>
				<pre href="http://www.xml.com/lpt/a/1633"><![CDATA[<content type="html">The &lt;code>atom:content&lt;/code> element either contains or links to the content of the entry. The content of &lt;code>atom:content&lt;/code> is &lt;a href="http://www.ietf.org/rfc/rfc3066.txt">Language-Sensitive&lt;/a>.</content>]]></pre>
				<pre href="http://www.xml.com/lpt/a/1633"><![CDATA[<content type="image/png">
iVBORw0KGgoA … TAAAAAElFTkSuQmCC
</content>]]></pre>
				<pre href="http://www.xml.com/lpt/a/1633"><![CDATA[<content src="image.png" type="image/png"/>]]></pre>
			</slide>
			<slide>
				<title>Atom Categories</title>
				<ul>
					<li>Atom allows to assign categories to entries</li>
					<ul>
						<li>each <elem>category</elem> element must have a <atom>term</atom> attribute for the category</li>
						<li>an optional <atom>scheme</atom> identifies the categorization scheme (ontology, taxonomy, …)</li>
						<li>an optional <atom>label</atom> attribute provides a human-readable label for the category</li>
					</ul>
					<li><link href="atompub">AtomPub</link> defines a document format for <link href="atom-category-documents"/></li>
					<li>Three different cases of categorization can be distinguished</li>
					<ol>
						<li>use a well-known scheme (such as <em>Dublin Core</em>)</li>
						<li>use a private but well-designed scheme (which has a URI and can be reused reliably)</li>
						<li>use tags without schemes, which then are little more than content labels</li>
					</ol>
				</ul>
			</slide>
		</part>
		<part id="atompub">
			<title short="AtomPub">Atom Publishing Protocol (AtomPub)</title>
			<slide>
				<title>RESTful Syndication</title>
				<ul>
					<li>Atom is a format for retrieving a set of entries as a feed document</li>
					<ul>
						<li>feeds often are time-based and are refreshed periodically or whenever needed</li>
						<li>feeds can use any other strategy for deciding what to publish</li>
					</ul>
					<li>Read-only access to feeds should be complemented by full access</li>
					<ul>
						<li>full access needs the <q>CUD</q> out of the <q>CRUD</q> set of operations</li>
						<li>many Web-centric technologies try to build on the Web's REST model of interaction</li>
					</ul>
					<li>AtomPub builds on Atom and adds a RESTful protocol on top of it</li>
					<ul>
						<li><http>POST</http> for creating new entries (sending the request to the collection)</li>
						<li><http>PUT</http> for updating existing entries (overwriting the existing entry)</li>
						<li><http>DELETE</http> for deleting entries from a collection</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Collections, Members, Entries, Media</title>
				<ul>
					<li>AtomPub's top-level concept is a <em>collection</em></li>
					<ul>
						<li>collections are used for managing and organizing <em>members</em></li>
						<li>Atom feed documents are the representation of collections</li>
						<li>collections just exist; there is no way of interacting with them</li>
					</ul>
					<li>Members of a collection can be <em>entry</em> and <em>media</em> resources</li>
					<ul>
						<li>entry resources represent metadata and are represented as Atom entries</li>
						<li>media resources can have any media type and are the data described by entries</li>
						<li>a <em>media link entry</em> is an entry associated with a member</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Atom/AtomPub Data Model</title>
				<img src="atom-data-model.png" style="height : 75% ; margin : 2% ; " title="Atom/AtomPub Data Model"/>
			</slide>
			<slide>
				<title>Protocol Summary</title>
					<table border="1" cellpadding="20" style="width : 90% ; margin : 2% ; ">
						<thead>
							<tr valign="top">
								<th>Resource</th>
								<th>HTTP Method</th>
								<th>Representation</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody>
							<tr valign="top">
								<td>Introspection</td>
								<td>
									<http>GET</http>
								</td>
								<td><link href="atom-service-documents">Atom Service Document</link></td>
								<td>Enumerates a set of collections and lists their URIs and other information about the collections</td>
							</tr>
							<tr valign="top">
								<td>Collection</td>
								<td>
									<http>GET</http>
								</td>
								<td>Atom Feed</td>
								<td>A list of member of the collection (this may be a subset of all entries in the collection)</td>
							</tr>
							<tr valign="top">
								<td>Collection</td>
								<td>
									<http>POST</http>
								</td>
								<td>Atom Entry</td>
								<td>Create a new entry in the collection</td>
							</tr>
							<tr valign="top">
								<td>Member</td>
								<td>
									<http>GET</http>
								</td>
								<td>Atom Entry</td>
								<td>Get the Atom Entry</td>
							</tr>
							<tr valign="top">
								<td>Member</td>
								<td>
									<http>PUT</http>
								</td>
								<td>Atom Entry</td>
								<td>Update the Atom Entry</td>
							</tr>
							<tr valign="top">
								<td>Member</td>
								<td>
									<http>DELETE</http>
								</td>
								<td>n/a</td>
								<td>Delete the Atom Entry from the collection</td>
							</tr>
						</tbody>
					</table>
			</slide>
			<slide id="collection-management">
				<title>Collection Management</title>
				<ul>
					<li>Managing collections is outside the scope of AtomPub</li>
					<ul>
						<li>AtomPub allows interactions with existing collections</li>
						<li>Collection management is inaccessible or using a proprietary protocol</li>
					</ul>
					<li><q>Metacollections</q> (collections of collections) can extend AtomPub</li>
					<ul>
						<li>each member in a metacollection corresponds with a collection</li>
						<li>accessing a metacollection means managing collections</li>
						<li>AtomPub's existing features can be reused for collection management</li>
					</ul>
					<li>Ongoing discussion in the Atom community</li>
					<ul>
						<li>currently there is no widely established method</li>
					</ul>
				</ul>
			</slide>
			<slide id="atom-service-documents">
				<title>Service Documents</title>
				<blockquote>Service Documents represent server-defined groups of Collections, and are used to initialize the process of creating and editing resources.</blockquote>
				<ul>
					<li>The <q>real</q> top-level construct of AtomPub is the <em>workspace</em></li>
					<ul>
						<li>collections on a server are organized into different workspaces</li>
						<li>workspaces have no AtomPub semantics and no operations can be performed on them</li>
					</ul>
					<li>Service documents list constraints on the members of collections</li>
					<ul>
						<li><atom>accept</atom> specifies a comma-separated list of media ranges (with <atom>entry</atom> as special value)</li>
						<li><atom>categories</atom> defines the list of categories that can be applied to members (can be <atom>fixed</atom>)</li>
						<li>AtomPub servers are likely to reject operations not satisfying these constraints</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Service Document Example</title>
				<listing src="atom-service.xml"/>
			</slide>
			<slide id="atom-category-documents">
				<title>Category Documents</title>
				<ul>
					<li>Categories are important for creating and reading entries</li>
					<ul>
						<li>they may contain metadata using any classification scheme</li>
					</ul>
					<li><link href="atom-service-documents"/> contain a list of allowed categories</li>
					<li>AtomPub defines a document format for standalone category documents</li>
					<ul>
						<li>a useful interface between AtomPub systems and other systems using classification schemes</li>
						<li>REST makes it important to make relevant resources accessible</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Category Document Example</title>
				<listing src="atom-category.xml"/>
			</slide>
		</part>
		<part>
			<title>Extending Atom/AtomPub</title>
			<slide>
				<title>Atom/AtomPub as Foundation</title>
				<ul>
					<li>Atom/AtomPub can be used as a foundation</li>
					<ul>
						<li>apply the methodology of <link href="restful-ws-design"/></li>
						<li>identify missing representations/links/states</li>
						<li>add these to the Atom/AtomPub model</li>
					</ul>
					<li>Atom has a well-defined extension model</li>
					<ul>
						<li><em>foreign markup</em> must be silently ignored by Atom processors</li>
						<li><em>foreign markup</em> is not allowed to change the semantics of Atom markup</li>
						<li>every Atom extension must be well-behaving with plain Atom processors</li>
					</ul>
					<li>Atom can serve as a good example for extensible markup</li>
					<ul>
						<li>if you're not using Atom, consider using <a href="http://tools.ietf.org/html/rfc4287#section-6">Atom's extension model</a></li>
					</ul>
				</ul>
			</slide>
			<slide id="restful-ws-design">
				<title>RESTful Web Service Design</title>
				<ul>
					<li>URIs are used for <link href="identification-constraint">resource identification</link></li>
					<li>HTTP's methods are used as the <link href="interface-constraint">uniform interface</link></li>
					<li><link href="self-describing-constraint">Representations</link> can use any syntax and structure</li>
					<li><link href="hypermedia-constraint">Hypermedia</link> is based on links in representations</li>
					<li>Use transaction resources to create <link href="stateless-constraint">stateless interactions</link></li>
				</ul>
			</slide>
			<slide>
				<title>RESTful Web Service Design Procedure</title>
				<ol>
					<li>Figure out the data set</li>
					<li>Split the data set into resources</li>
					<li><link href="identification-constraint">Name the resources with URIs</link></li>
					<li>Expose a subset of the <link href="interface-constraint">uniform interface</link></li>
					<li><link href="self-describing-constraint">Design the representation(s)</link> accepted from the client</li>
					<li><link href="self-describing-constraint">Design the representation(s)</link> served to the client</li>
					<li><link href="hypermedia-constraint">Design hypermedia integration</link> with other resources</li>
					<li>Figure out <link href="stateless-constraint">the normal control flow</link></li>
					<li>Figure out error conditions</li>
				</ol>
			</slide>
		</part>
		<part id="atom-conclusions">
			<title>Conclusions</title>
			<slide>
				<title>Simple Syndication</title>
				<ul>
					<li>RESTful services depend on representations</li>
					<li>Some aspects of representations may be generic</li>
					<li>Reuse existing patterns instead of reinventing the wheel</li>
					<li>Atom/AtomPub at least are useful design patterns</li>
					<li>(So far) there is no "JSON/RDF Atom" (but watch <a href="http://amundsen.com/media-types/collection/">Collection+JSON</a> and <a href="http://www.w3.org/2012/ldp/" title="Linked Data Platform">LDP</a>)</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xquery-1">
		<title short="XQuery 1">XML Query (XQuery) – Part I</title>
		<date>2013-11-20</date>
		<toc class="resources"><a href="http://www.w3.org/TR/xquery" title="W3C XQuery Specification">XQuery Spec</a>&#160;· <a href="http://www.ibm.com/developerworks/xml/library/x-wxxm34.html" title="IBM developerWorks">XQuery/XSLT Comparison</a></toc>
		<toc class="abstract">The <em>XML Query (XQuery)</em> language has been designed to query collections of XML documents. It is thus different from XSLT, which primarily transforms one document at a time. However, the core of both languages is XPath 2.0, which means that learning XQuery (and XSLT 2.0) is not very hard when starting with a solid knowledge of XPath 2.0. XQuery's main concept is an expression language which supports iteration and binding of variables to intermediate results. XQuery has been built on top of XPath 2.0, which means it uses the same foundation as XSLT 2.0. Both languages have a large overlap, and according to personal preferences and the XML task, one language may be preferred over the other. Features such as <em>user-defined functions</em> and <em>schema-awareness</em> bring XQuery even closer to XSLT 2.0, making the decision to choose one over the other mostly a question of personal preference.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>XQuery in the XML Landscape</title>
			<slide>
				<title>XSLT using XPath</title>
				<img style="width : 86% ; margin : 4% ; " src="xslt-overview.png" title="XSLT Processing"/>
			</slide>
			<slide>
				<title>XQuery using XPath</title>
				<img style="width : 86% ; margin : 4% ; " src="xquery-overview-filesystem.png" title="File-based XQuery Processing"/>
			</slide>
			<slide>
				<title>XQuery using XPath + Database</title>
				<img style="width : 86% ; margin : 4% ; " src="xquery-overview-dbms.png" title="DB-based XQuery Processing"/>
			</slide>
		</part>
		<part id="xquery-expressions">
			<title>XQuery Expressions</title>
			<part>
				<title>Syntax Matters</title>
				<slide>
					<title>XML Syntax</title>
					<ul>
						<li>XML syntax is good (and bad …)</li>
						<ul>
							<li>XML is well-known and supported by many tools</li>
							<li>XML is verbose and hard to parse for humans</li>
						</ul>
						<li>XSLT's XML syntax is good (and bad …)</li>
						<ul>
							<li>it is easy to use for experienced XML users</li>
							<li>and a nightmare to get used to for XML beginners</li>
							<li>it can be easily fed to itself for advanced applications (meta-stylesheets)</li>
							<li>which only advanced XSLT programmers will ever do</li>
						</ul>
						<li>Even XSLT is not completely XMLized</li>
						<ul>
							<li>XSLT language constructs are XML elements and attributes</li>
							<li>XPath expressions use their own non-XML syntax (hard to process in XSLT )</li>
							<li>XSLT is a compromise between XML and non-XML</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XQuery Syntax</title>
					<ul>
						<li>XQuery should become the new query language for data</li>
						<ul>
							<li>some say for any data (because relational data can be represented as XML anyway)</li>
							<li>others say for XML data only</li>
							<li>either way, XQuery will become an important language</li>
						</ul>
						<li>XML syntax has been perceived as something people don't like</li>
						<ul>
							<li>there is no hard evidence that XML syntax really is an acceptance problem</li>
							<li>but many people think this might be the case for a query language</li>
							<li>non-XML syntaxes can be more compact than XML syntaxes</li>
						</ul>
						<li>Query language specialists are used to SQL's keyword-based syntax</li>
						<ul>
							<li>XQuery imitates this approach to make it easier to switch</li>
							<li>XML shows up anyway because XQuery constructs XML</li>
							<li>you can't really escape XML when you are working with XML …</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XQuery Syntax Example</title>
					<listing src="book-example.xq"/>
				</slide>
				<slide>
					<title>XQueryX Syntax Example</title>
					<listing src="book-example.xqx" line="8-34"/>
				</slide>
			</part>
			<part id="xquery-flwor">
				<title short="FLWOR">For Let Where Order Return (FLWOR)</title>
				<slide>
					<title>XPath and XQuery</title>
					<ul>
						<li>Every XPath expression is a valid XQuery expression</li>
						<ul>
							<li>if you are good at XPath, you can reuse a lot of your knowledge</li>
							<li>XQuery provides alternative expressions and missing functionality</li>
						</ul>
						<li>XPath is a language for selecting nodes in existing documents</li>
						<ul>
							<li>XPath has no language features to construct new XML trees</li>
							<li>re-ordering a tree (i.e., sorting) also involves constructing a new tree</li>
						</ul>
						<li>XPath is more relevant for XSLT/XQuery experts</li>
						<ul>
							<li>advanced XPath concepts will take you very far</li>
						</ul>
						<li>XQuery expressions can be used to simplify XPaths</li>
						<ul>
							<li>in the same way as in XSLT, there is a trade-off in complexity between the languages</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XPath <q>vs.</q> XQuery</title>
					<ul>
						<li>Choosing a certain style can be a question of taste</li>
					</ul>
					<pre>//reference[starts-with(date/@value, '2000')]/title</pre>
					<listing src="for-where-return.xq" line="3-5"/>
				</slide>
				<slide>
					<title>XQuery's Central Construct</title>
					<ul>
						<li>FLWOR is pronounced <q>flower</q> (it went through several syntax iterations)</li>
						<ul>
							<li>must have at least one <xq>for</xq> or <xq>let</xq></li>
							<li>may have <xq>where</xq> and <xq>order by</xq></li>
							<li>must have <xq>return</xq></li>
						</ul>
						<li>Iteration over a sequence of items</li>
						<ul>
							<li>similar to <xslte>for-each</xslte> or similar loop constructs</li>
							<li><xq>where</xq> is comparable to XPath predicates</li>
						</ul>
					</ul>
				</slide>
				<slide id="xquery-for">
					<title>FLWOR – For</title>
					<ul>
						<li>Iteration over an input sequence</li>
						<ul>
							<li>for each item in the input sequence, a result is calculated</li>
							<li>the result of the <xq>for</xq> clause is the concatenation of all these results</li>
						</ul>
						<li>If there is only a <xq>return</xq>, it is the same as XPath's <link href="xpath20-iterations"/></li>
					</ul>
					<pre>for $i in (1 to 10) return $i * $i</pre>
					<listing src="for-return.xq"/>
				</slide>
				<slide id="xquery-let">
					<title>FLWOR – Let</title>
					<ul>
						<li>Declares a variable and assigns a value to it</li>
						<ul>
							<li>may use previously assigned variables</li>
							<li>can be used any number of times mixed in any order with <xq>for</xq> clauses</li>
						</ul>
					</ul>
					<listing src="let-return.xq"/>
					<listing src="for-let-return.xq"/>
				</slide>
				<slide>
					<title>For &amp; Let</title>
					<ul>
						<li>Variables in most cases are used for convenience</li>
						<ul>
							<li>they avoid repeating things and often result in a more structured query expression</li>
							<li>writing XQueries should not be an exercise in minimizing the character count</li>
						</ul>
						<li>For single items, <xq>for</xq> and <xq>let</xq> can be interchanged (handy for XPath)</li>
					</ul>
					<pre>let $x := 'whatever' return …</pre>
					<pre>for $x in 'whatever' return …</pre>
				</slide>
				<slide id="xquery-where">
					<title>FLWOR – Where</title>
					<ul>
						<li>Filtering the items from <xq>for</xq> and <xq>let</xq> clauses</li>
						<ul>
							<li>there may be at most one <xq>where</xq> clause in a FLWOR expression</li>
							<li>it has to appear after all <xq>for</xq> and <xq>let</xq> clauses</li>
						</ul>
						<li>A <xq>where</xq> clause almost always uses a variable</li>
						<ul>
							<li>they act as filters of the sequences generated by <xq>for</xq> clauses</li>
							<li>they act based on the value of the items in that sequence</li>
						</ul>
					</ul>
					<listing src="for-where-return.xq"/>
					<ul>
						<li>Predicates in XPath expressions do the exact same thing</li>
						<ul>
							<li>but predicates can only be applied to nodes</li>
							<li>SQL users find the <xq>where</xq> approach easier to understand</li>
						</ul>
					</ul>
				</slide>
				<slide id="xquery-order">
					<title>FLWOR – Order by</title>
					<ul>
						<li>FLWOR results are evaluated in the order resulting from the <xq>for</xq> clauses</li>
						<ul>
							<li>for nested clauses, this means a nested evaluation of <xq>for</xq> clauses</li>
							<li>this will often reflect the document order (depending on the <xq>for</xq> XPaths)</li>
						</ul>
						<li>Any order other than this has to be achieved by sorting</li>
						<ul>
							<li>multiple sort keys can be specified separated by commas</li>
							<li>sorting can be done <xq>ascending</xq> or <xq>descending</xq></li>
						</ul>
					</ul>
					<listing src="for-let-order-return.xq"/>
				</slide>
				<slide id="xquery-return">
					<title>FLWOR – Return</title>
					<ul>
						<li>Required in every FLWOR expression</li>
						<li>Constructs new nodes and fills them with values</li>
						<ul>
							<li>element constructors can be used to generate elements</li>
							<li>attribute constructors can be used to generate attributes</li>
						</ul>
					</ul>
					<listing src="for-let-order-return-attributes.xq"/>
				</slide>
			</part>
		</part>
		<part>
			<title>XQuery &amp; XSLT</title>
			<slide>
				<title>XPath 2.0 vs. XSLT 2.0</title>
				<ul>
					<li><link href="xpath20">XPath 2.0</link> is powerful but incomplete</li>
					<ul>
						<li>cannot create nodes (only selection of existing nodes)</li>
						<li>does not support user-defined functions</li>
						<li>no support for grouping</li>
						<li>no support for sorting</li>
					</ul>
					<li><link href="xslt20-1">XSLT 2.0</link> extends XPath 2.0 with additional features</li>
					<li>XSLT 2.0 adds more features which were missing in <link href="xslt-1">XSLT 1.0</link></li>
					<ul>
						<li><link href="xslt20-analyze-string"><xslte>analyze-string</xslte></link> for processing strings</li>
						<li><xpath>format-date()</xpath> and <xpath>format-number()</xpath> for formatted values</li>
						<li><link href="xslt20-grouping"><xslte>for-each-group</xslte></link> for easy grouping and access to group information</li>
					</ul>
					<li>XSLT's <em>functional programming model</em> has nothing to do with XPath</li>
				</ul>
			</slide>
			<slide>
				<title>Turing Completeness</title>
				<ul>
					<li><link href="xslt20-1">XSLT 2.0</link> and XQuery are both <a href="http://en.wikipedia.org/wiki/Turing-complete">Turing complete</a></li>
					<ul>
						<li>any algorithm computing output from input can be implemented</li>
						<li>Turing completeness says nothing about how <em>appropriate</em> a language is for a task</li>
					</ul>
					<li>Choosing between XSLT 2.0 and XQuery is a matter of taste and politics</li>
					<ul>
						<li>the <em>functional style</em> of XSLT is hard to get used to</li>
						<li>most people feel more comfortable with the more traditional design of XQuery</li>
						<li>providing and using one of the languages is a long-term decision</li>
					</ul>
					<li>Choosing between XSLT 2.0 and XQuery also depends on the task</li>
					<ul>
						<li>simple extraction of XML content is mostly XPath 2.0 anyway</li>
						<li>generating rigid schemas from XML sources works well in both languages</li>
						<li>document processing (<link href="mixed-content"/>) is better done with XSLT 2.0</li>
						<li>large scale data processing is better done with XQuery</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XSLT Assumptions</title>
				<ul>
					<li>Transformations process the complete input</li>
					<ul>
						<li>the <link href="xslt-processing-model"/> works well for processing most nodes</li>
						<li><em>Built-In Templates</em> can be used for applying default transformations</li>
					</ul>
					<li>XSLT users are highly skilled in XML</li>
					<ul>
						<li>XSLT's XML syntax is hard to learn and use for non-XML experts</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XQuery Assumptions</title>
				<ul>
					<li>Queries only extract selected part of the input</li>
					<ul>
						<li>there is no default behavior</li>
						<li>understanding the control flow in XQuery is much easier than in XSLT</li>
					</ul>
					<li>XQuery authors are not necessarily XML experts</li>
					<ul>
						<li>input and output in many cases will be XML</li>
						<li>the language syntax should be as human-oriented as possible</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XSLT BlogXML Processor</title>
				<listing src="blog2html.xsl"/>
			</slide>
			<slide>
				<title>XQuery BlogXML Processor</title>
				<listing src="blog2html.xq" line="3-18"/>
			</slide>
			<slide>
				<title>2-Step vs. 1-Step</title>
				<ul>
					<li>Web applications often are built as <em>multi-tier applications</em></li>
					<li>REST services provide the interface to the data</li>
					<ul>
						<li>they provide access to resources which are managed by the service</li>
						<li>in many cases the data representation is some XML format</li>
					</ul>
					<li>Interfaces than use that data in various ways</li>
					<ul>
						<li>UIs may present it in HTML</li>
						<li>APIs may present it in some API-specific way (e.g., import/export)</li>
					</ul>
					<li>XQuery is well-suited to retrieve data from an XDBMS</li>
					<li>XSLT is well-suited to transform data to a specific presentation format</li>
				</ul>
			</slide>
			<slide>
				<title>Web App with XQuery &amp; XSLT</title>
				<img style="width : 88% ; margin : 4% ; " src="web-app-tiers.png" title="Web Application Tiers with XQuery and XSLT"/>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XQuery vs. XSLT</title>
				<ul>
					<li>XQuery is a complete programming language</li>
					<li>XSLT can do everything XQuery can and vice versa</li>
					<li>Choosing one over the other depends on task and taste</li>
					<li>REST scenarios have good places for both languages</li>
				</ul>
			</slide>
			<slide>
				<title>Clearer Queries</title>
				<ul>
					<li>XPath is too condensed for many users</li>
					<li>XQuery provides a less compact and easier accessible syntax</li>
					<li>XQuery provides features which are not part of XPath</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="xdb">
		<title short="xDB">Setting Up xDB</title>
		<date>2013-11-25</date>
		<toc class="resources"><a href="https://community.emc.com/community/edn/xmltech/content" title="ECN Space: XML Technologies">EMC&#160;XML&#160;Home</a>&#160;· <a href="https://community.emc.com/docs/DOC-7711">xDB&#160;Manuals</a></toc>
		<toc class="abstract">XML databases are not fundamentally different from other database engines: They provide support to store and query potentially large amounts of data. xDB is EMC's XML Database product, and is implemented in Java. It therefore can be used on any computer with Java runtime support. xDB has a database server, which has to be started and then waits for incoming connection requests. xDB also has a Java client which can be used to connect to the server, and then provides administrative as well as user functionality. In this lecture, we will install xDB on all student computers, and ingest some XML data into an XML database managed by xDB.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
	</presentation>
	<presentation id="xquery-2">
		<title short="XQuery 2">XML Query (XQuery) – Part II</title>
		<date>2013-12-02</date>
		<toc class="resources"><a href="http://en.wikipedia.org/wiki/SQL/XML" title="Wikipedia: SQL/XML">SQL/XML</a></toc>
		<toc class="abstract">XML and relational databases are not entirely different things: they share the basic model of providing support for storing and processing (potentially large amounts of) data. SQL/XML is an approach to bridge the two worlds of relational and XML databases, by allowing relational database to produce XML, and even to store and query XML. In the second half of this lecture we are taking a second look at XQuery, specifically its processing model and the way how queries are specifying the input documents to XQuery expressions.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part>
			<title>XML Storage in Databases</title>
			<slide>
				<title>Model Mapping</title>
				<ul>
					<li>Relational databases are not good tools for storing XML</li>
					<ul>
						<li>they might be appropriate if the schema disallows problematic constructs</li>
						<li>they often are already deployed and applications must live with them</li>
					</ul>
					<li>If the data model is ER-oriented, relational databases are good tools</li>
					<ul>
						<li>XML may be invisible from the model point of view</li>
						<li>parts of the model may be encoded as an XML schema</li>
					</ul>
					<li>If the XML is not visible in the model, it can be structurally inaccessible</li>
					<ul>
						<li>e.g., a product catalog may contain product descriptions in XHTML rich text snippets</li>
						<li>for managing the product catalog data, the XHTML is not relevant</li>
					</ul>
					<li>If the XML is part of the model, it should be accessible</li>
					<ul>
						<li>if the product catalog XHTML contains links to other products, these links are important</li>
						<li>they could be extracted (creating redundant and hard to maintain data)</li>
						<li>if they are hidden in the XHTML, all XHTML snippets have to be parsed</li>
						<li>ideally, the database should be able to <q>query the XHTML snippet</q></li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XML is Text</title>
				<ul>
					<li>XML documents can be stored as text</li>
					<ul>
						<li>databases typically have various datatypes for text storage</li>
						<li>if the database supports Unicode, any XML document can be stored</li>
					</ul>
					<li>The XML structure is completely invisible to the database</li>
					<ul>
						<li>working with the XML requires querying and parsing the XML text</li>
						<li>this kind of storage does not allow any querying of the XML content</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XML → ∗LOB</title>
				<img style="width : 90% ; margin : 2% ; " src="xml-storage-lob.png"/>
			</slide>
			<slide id="xdbms-xmldatatype">
				<title>XML as a Datatype</title>
				<ul>
					<li>SQL supports a wide variety of datatypes</li>
					<ul>
						<li>typed values are better than untyped values (they enable type-specific operations)</li>
						<li>XML can be regarded as just another data type</li>
					</ul>
					<li>Introducing a datatype lets the database recognize the data</li>
					<ul>
						<li>XML data can be stored in some format (a <q>persistent DOM</q>)</li>
						<li>databases can provide functionality avoiding parsing/serialization (DOM-based)</li>
					</ul>
				</ul>
			</slide>
			<slide id="xdbms-xmltype">
				<title>XML Datatype</title>
				<img style="width : 90% ; margin : 2% ; " src="xml-storage-datatype.png"/>
			</slide>
			<slide>
				<title>Mapping XML to Models</title>
				<ul>
					<li>Model-relevant data must be mapped to the database structures</li>
					<ul>
						<li>this assumes there is a ER-model which describes the database structure</li>
						<li>mapping XML is easy by definition because the XML is ER-compliant</li>
					</ul>
					<li>Is the data accessed as table data?</li>
					<ul>
						<li>if shredded data is only used to assemble it again, it is just performance overhead</li>
						<li>if shredded data is accessed relationally, then shredding makes sense</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Shredding (XML → Columns)</title>
				<img style="width : 90% ; margin : 2% ; " src="xml-storage-shredding.png"/>
			</slide>
			<slide>
				<title>XML as First-Class Citizen</title>
				<ul>
					<li>The <link href="xdbms-xmltype"/> defines XML as a sub-concept of ER</li>
					<ul>
						<li>the overall structure of the database is relational</li>
						<li>attributes may be of type XML, which means storing trees in tables</li>
					</ul>
					<li>Tables are not the only way to see the world</li>
					<ul>
						<li>XML trees are an <em>alternative</em> to tables, not a <em>datatype</em></li>
						<li>XML-centric applications should not be forced to use tables at all</li>
					</ul>
					<li>XML can be regarded as replacing the ER-concept altogether</li>
					<ul>
						<li>the database simply stores XML documents</li>
						<li>applications can store, query, update, and manage XML documents in the database</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>XML DBMS</title>
				<img style="width : 90% ; margin : 2% ; " src="xml-storage-xdbms.png"/>
			</slide>
		</part>
		<part>
			<title>XML in Relational Databases</title>
			<slide>
				<title>RDBish XML</title>
				<ul>
					<li>XML schemas can be designed with databases in mind</li>
					<ul>
						<li>avoid unbounded repetitions of elements</li>
						<li>avoid choices</li>
						<li>avoid ordered content</li>
						<li>avoid mixed content</li>
					</ul>
					<li>Many XML schemas are designed RDBish for compatibility reasons</li>
					<ul>
						<li>it was decided that the XML should enable an easy mapping to relational structures</li>
						<li>the person designing the schema has a ER-structured brain</li>
						<li>the schema has been generated from a relational database schema</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Problematic XML</title>
				<ul>
					<li>XML in its full glory is too much for tables</li>
					<ul>
						<li>XML has been developed as a document format</li>
						<li>XML is about hierarchy (which <em>intentionally</em> have been left out of ER)</li>
						<li>XML is about highly irregular structures</li>
					</ul>
					<li>XML often is said to have two <q>flavors</q></li>
					<ul>
						<li><em>data-oriented XML</em>: regular data which can be easily mapped to tables</li>
						<li><em>document-oriented XML</em>: irregular structures which are hard to map to tables</li>
						<li>real-world XML often is a bit of both (e.g., <em>content</em> and <em>metadata</em>)</li>
					</ul>
					<li>Hybrid approaches sometimes are a good solution</li>
					<ul>
						<li>data-oriented can be shredded and stored in tables</li>
						<li>the document-oriented rest is stored as one object (text or <code>XML</code>)</li>
					</ul>
				</ul>
			</slide>
			<part id="sqlxml">
				<title>SQL/XML</title>
				<slide>
					<title>SQL/XML:2003</title>
					<ul>
						<li>SQL/XML provides XML Support in RDBMSs</li>
						<ul>
							<li>it introduces <link href="xdbms-xmldatatype"/></li>
							<li>it introduces a number of operations for generating XML from query results</li>
							<li>it defines mappings to bridge both worlds (SQL and XML)</li>
						</ul>
						<li>SQL/XML does not change anything about the database model</li>
						<ul>
							<li>data is still stored in tables only</li>
							<li>a column of a table may use the <code>XML</code> type</li>
							<li>queries may return results in XML rather than as SQL result sets</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>SQL/XML Example</title>
					<pre>SELECT
  e.EmpId,
  e.FirstName,
  e.LastName,
  e.StartDate,
  e.EndDate
FROM Employees e WHERE e.EmpId = 12</pre>
					<pre>SELECT
  XMLELEMENT(NAME "employee",
    XMLATTRIBUTES(e.EmpId as "id"),
    XMLELEMENT(NAME "names",
      XMLELEMENT(NAME "first", e.FirstName),
      XMLELEMENT(NAME "last", e.LastName)),
    XMLELEMENT(NAME "hire-dates",
      XMLATTRIBUTES(e.StartDate as "start", e.EndDate as "end")))
FROM Employees e WHERE e.EmpId = 12</pre>
				</slide>
				<slide>
					<title>SQL/XML:2008</title>
					<ul>
						<li>Adds the concept of <em>XML Tables</em></li>
						<li>XML Tables are not tables, they are containers for XML</li>
						<li>SQL/XML:2008 changes the database's data model</li>
						<ul>
							<li>it is now possible to have a database with <q>no tables</q></li>
							<li>likely use cases are to have both: traditional and XML tables</li>
						</ul>
						<li>SQL/XML:2008 defines a hybrid database: relational and XML database</li>
					</ul>
				</slide>
			</part>
		</part>
		<part id="xquery-processing">
			<title>Processing Model</title>
			<slide>
				<title>Prolog</title>
				<ul>
					<li>Prolog comes in front of the query</li>
					<li>Declare namespaces, global variables, global options, external variables etc.</li>
					<li>Important declarations</li>
					<ul>
						<li><code>declare namespace foo = "http://bar";</code></li>
						<li><code>declare option xhive:queryplan-debug "true";</code></li>
					</ul>
					<li>Predefined namespace prefixes</li>
					<ul>
						<li><code>xml, xmlns, fn, xs, xsi, op, xdt, local</code></li>
						<li>plus implementation defined prefixes (e.g. <code>xhive</code>)</li>
					</ul>
				</ul>
			</slide>
			<slide id="xquery-tuple-stream">
				<title>Tuple Stream</title>
				<ul>
					<li>FLWOR expressions are the central expression producing results</li>
					<ul>
						<li>nested <xq>for</xq> loops turn sorting into a non-trivial task</li>
						<li>the concept of a <em>tuple stream</em> formally defines FLWOR evaluation</li>
					</ul>
					<li>Each FLWOR expression is generating a tuple stream</li>
					<ul>
						<li><xq>for</xq> and <xq>let</xq> generate a sequence of bound variables, the <em>tuple stream</em></li>
						<li><xq>where</xq> acts as a filter testing tuples against a constraint (discarding some tuples)</li>
						<li><xq>order by</xq> can be used to reorder the (possibly filtered) tuple stream</li>
						<li><xq>return</xq> is evaluated once for each tuple in the filtered, reordered stream</li>
						<li>the result of the expression are the concatenated results of all <xq>return</xq> evaluations</li>
					</ul>
				</ul>
			</slide>
			<slide id="xquery-serialization">
				<title>Serialization</title>
				<ul>
					<li>XQuery creates an <a href="http://dret.net/lectures/xml-fall08/xdm">XDM</a> instance as a result</li>
					<li>XDM instances are sequences of items</li>
					<ul>
						<li>items can be atomic values</li>
						<li>items can be nodes which are nested to form trees</li>
					</ul>
					<li>XQuery itself is not concerned with how to serialize XDM instances</li>
					<ul>
						<li>the language works on XDM and produces XDM</li>
					</ul>
					<li><a href="http://www.w3.org/TR/xslt-xquery-serialization/">XSLT 2.0 and XQuery 1.0 Serialization</a> defines the serialization of XDM instances</li>
					<ul>
						<li>the specification can be used for XSLT 2.0 and XQuery 1.0</li>
						<li>if other serializations are required, this does not affect the core standards</li>
						<li>currently supported output methods are <a href="http://www.w3.org/TR/xslt-xquery-serialization/#xml-output">XML</a>, <a href="http://www.w3.org/TR/xslt-xquery-serialization/#xhtml-output">XHTML</a>, <a href="http://www.w3.org/TR/xslt-xquery-serialization/#html-output">HTML</a>, and <a href="http://www.w3.org/TR/xslt-xquery-serialization/#text-output">Text</a></li>
					</ul>
					<li>Text output means that non-markup structures can be created directly</li>
				</ul>
			</slide>
		</part>
		<part>
			<title>XQuery Sources</title>
			<slide>
				<title>XQuery using Files</title>
				<img style="width : 86% ; margin : 4% ; " src="xquery-overview-filesystem.png" title="File-based XQuery Processing"/>
			</slide>
			<slide>
				<title>XQuery using an XML Database</title>
				<img style="width : 86% ; margin : 4% ; " src="xquery-overview-dbms.png" title="DB-based XQuery Processing"/>
			</slide>
			<slide>
				<title>Specifying XQuery Input</title>
				<ul>
					<li><code href="http://www.w3.org/TR/xpath-functions/#func-doc">doc()</code> or <code href="http://www.w3.org/TR/xpath-functions/#func-collection">collection()</code> specify input</li>
					<li>Input can be a single XML source file or an entire database</li>
					<li>All XQueries have an initial context item</li>
					<ul>
						<li>default starting point for unqualified XPath expressions</li>
						<li>in xDB, this is the library, document, or node of the XQuery</li>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Finding Activities Saxon)</title>
				<listing src="find-by-location-oxygen.xq"/>
			</slide>
			<slide>
				<title>Finding Activities (xDB)</title>
				<listing src="find-by-location-xdb.xq"/>
			</slide>
			<slide>
				<title>XQuery Input in xDB</title>
				<ul>
					<li>In xDB, <code>doc()</code> and <code>collection()</code> are synonymous</li>
					<li>Parameter is a string containing a URI</li>
					<ul>
						<li><code>doc('foo.xml')</code>: relative path within xDB</li>
						<li><code>doc('/bar/foo.xml')</code>: absolute path within xDB</li>
						<li><code>doc('http://www.example.com/foo.xml')</code>: HTTP request</li>
						<li><code>doc('xhive://foo/bar/../test.xml')</code>: complete xDB URI</li>
						<li><code>doc('file:///my/doc.xml')</code>: absolute local file URI</li>
						<li><code>doc('file:doc.xml')</code>: relative file URI</li>
					</ul>
					<li>Accessing a library (<code>doc('lib/')</code>) results in</li>
					<ul>
						<li>all documents in the library</li>
						<li>all documents in descendant libraries</li>
						<li>only works within xDB, not for file system</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>More XQuery Details</title>
			<slide>
				<title>Comma Operator</title>
				<ul>
					<li>Constructing sequences from separate expressions</li>
					<pre>&lt;a>123&lt;/a>, &lt;b>456&lt;/b></pre>
					<pre>doc("books.xml")//author, doc("books.xml")//title</pre>
					<li>Parentheses must be used to group expressions correctly</li>
					<pre>for $b in doc("books.xml")//book return   $b/title, <span style="color : red ; ">$b/author</span></pre>
					<pre>for $b in doc("books.xml")//book return ( $b/title, $b/author )</pre>
				</ul>
			</slide>
			<slide>
				<title>Whitespace in XQuery</title>
				<ul>
					<li>XQuery distinguishes three kinds of whitespace</li>
					<ul>
						<li><em>ignorable whitespace</em> occurring between syntax terminals (e.g., keywords)</li>
						<li><em>boundary whitespace</em> occurring between tags and/or enclosed expressions</li>
						<li><em>literal whitespace</em> occurring inside literals</li>
					</ul>
					<li><xq>boundary-space</xq> controls the interpretation of boundary whitespace</li>
					<ul>
						<li><xq>strip</xq> declares boundary whitespace to be insignificant</li>
						<li><xq>preserve</xq> declares boundary whitespace to be significant</li>
					</ul>
				</ul>
				<pre>declare boundary-space strip;
let $a := "Bob Glushko"
return
  &lt;book>
    &lt;title>Document Engineering&lt;/title>
    &lt;author> { $a } &lt;/author>
  &lt;/book></pre>
			</slide>
			<slide>
				<title>Constructors</title>
				<ul>
					<li>XQuery allows literal XML or <em>computed constructors</em></li>
					<li>Literal XML are called <em>direct constructors</em></li>
					<pre>&lt;book>
  &lt;title>Document Engineering&lt;/title>
  &lt;author>Bob Glushko&lt;/author>
  &lt;price currency="USD">29.99&lt;/price>
&lt;/book></pre>
					<li><em>Computed Constructors</em> can be used for calculating names</li>
					<pre>element "book" {
  element "title" { "Document Engineering" },
  element "author" { "Bob Glushko" },
  element "price" {
    attribute "currency" { "USD" },
    29.99
  }
}</pre>
					<li>XSLT has the same concepts (<link href="xslt-literal"/> and <link href="xslt-element"><xslte>element</xslte></link>)</li>
				</ul>
			</slide>
		</part>
		<part>
			<title>Conclusions</title>
			<slide>
				<title>XQuery vs. XSLT</title>
				<ul>
					<li>XQuery is a complete programming language</li>
					<li>XSLT can do everything XQuery can and vice versa</li>
					<li>Choosing one over the other depends on task and taste</li>
					<li>REST scenarios have good places for both languages</li>
				</ul>
			</slide>
		</part>
	</presentation>
	<presentation id="relax-ng">
		<title>RELAX NG</title>
		<date>2013-12-04</date>
		<toc class="resources"><a href="http://relaxng.org/" title='RELAXNG.org'>RELAX&#160;NG&#160;Home&#160;Page</a>&#160;· <a href="http://www.thaiopensource.com/relaxng/design.html">The Design of RELAX NG</a></toc>
		<toc class="abstract">Schema languages as a general concept in XML are used to (1) prescribe the allowed document structure, and/or (2) validate a document against a description of what is allowed in a document and what isn't. DTDs and XSDs are particularly important schema languages because DTDs are part of XML itself, and XSD was the first major improvement of the rather limited capabilities of DTDs. Recently, however, XSD is increasingly criticized for its complexity, and the RELAX NG schema language is gaining popularity instead. RELAX NG is a grammar-based schema language (like DTD and XSD), but adds a human-friendly syntax, the ability to use datatypes, and it removes the ability to allow validation to change a document.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>Design by Committee</title>
			<ul>
				<li>XSD was a political decision</li>
				<ul>
					<li>several schema languages were competing to replace DTDs</li>
					<li>DCD, DDML, SOX, XML Data, and XDR were inputs to XSD</li>
					<li>XSD became the first unreadable W3C specification</li>
					<li>implementing XSD correctly is hard (large number of specialized rules)</li>
				</ul>
				<li>Researchers were looking for a more elegant solution</li>
				<ul>
					<li>the underlying formalism should be well-defined and well-studied</li>
					<li>the schema language should be easy to learn and use</li>
					<li>lessons learned from DTDs should be included</li>
				</ul>
				<li>RELAX NG is the merger of two similar approaches</li>
				<ul>
					<li><em>Tree Regular Expressions (TREX)</em></li>
					<li><em>Regular Language description for XML (RELAX)</em></li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>RELAX NG +/-</title>
			<ul>
				<li>RELAX NG and XSD are direct competitors</li>
				<li>Advantages of RELAX NG</li>
				<ul>
					<li><link href="relaxng-compact"/></li>
					<li>the document element is well-defined</li>
					<li>SGML's <q><code>&amp;</code></q> is supported (<xsde>all</xsde> is extremely limited)</li>
					<li>non-deterministic content models</li>
				</ul>
				<li>Disadvantages of RELAX NG</li>
				<ul>
					<li>no datatype support (datatype libraries can be included)</li>
					<li>no modeling facilities in the spirit of XSD's type derivation</li>
					<li>less popular than XSD</li>
					<li>no support for XSD's numeric occurrence constraints (<xsd>minOccurs</xsd>/<xsd>maxOccurs</xsd>)</li>
				</ul>
			</ul>
		</slide>
		<slide>
			<title>RELAX NG Syntaxes</title>
			<img src="xml-technology-syntaxes.png" style="width : 90% ; margin : 4% ; "/>
		</slide>
		<part>
			<title>Principles</title>
			<slide>
				<title>Validation</title>
				<ul>
					<li>Validation should not change the document</li>
					<ul>
						<li>there are no default values</li>
					</ul>
					<li>Only schema↔instance tests are supported</li>
					<ul>
						<li>there is no type hierarchy as in XSD (schema↔schema)</li>
						<li>there are no identity constraints (instance↔instance)</li>
					</ul>
					<li>Grammars should not be restricted</li>
					<ul>
						<li>DTDs and XSD no not allow non-determinism</li>
						<li>RELAX NG allows non-deterministic content models</li>
						<pre>chess = white, (black, white)*, black?</pre>
					</ul>
				</ul>
			</slide>
			<slide>
				<title>Grammars</title>
				<ul>
					<li>RELAX NG grammars have a start symbol</li>
					<ul>
						<li>DTDs and XSD do not have start symbols</li>
					</ul>
					<li>Attributes are defined as part of the <q>content model</q></li>
					<ul>
						<li>a more homogeneous view of the XML document tree</li>
						<li>this allows alternatives of elements and attributes</li>
					</ul>
					<li>Grammars are a set of named rules</li>
					<ul>
						<li>rules define how an element is composed</li>
						<li>local definitions (nested specifications of content models) are possible</li>
					</ul>
				</ul>
			</slide>
		</part>
		<part>
			<title>Example</title>
			<slide>
				<title>DTD and XSD</title>
				<listing src="document.dtd"/>
				<listing src="document.xsd"/>
			</slide>
			<slide>
				<title>RELAX NG</title>
				<listing src="document.rng"/>
			</slide>
			<slide id="relaxng-compact">
				<title>RELAX NG Compact Syntax</title>
				<listing src="document.rnc"/>
			</slide>
		</part>
	</presentation>
	<presentation id="varia">
		<title>XML Varia</title>
		<date>2013-12-09</date>
		<toc class="resources"><a href="http://dret.typepad.com/dretblog/2009/08/data-models-metamodels-cosmologies.html">Data,&#160;Models,&#160;Metamodels,&#160;Cosmologies</a>&#160;· <a href="http://www.w3.org/TR/xml-id/" title='W3C "xml:id" Spec'>xml:id</a>&#160;· <a href="http://www.w3.org/TR/xinclude/" title='W3C "XML Inclusions (XInclude)" Spec'>XInclude</a></toc>
		<toc class="abstract">The first half of the lecture compares XML to alternatives, that also are used as ways to represent and/or manage and/or exchange and/or process data. The most relevant approaches in this space are RDF, JSON, and tabular/relational models such as SQL or NoSQL. One of the reasons why using XML-based approaches for data representation, management, interchange, and processing, is that there is a large landscape of existing standards and technologies and tools, and that for many problems it thus is possible to approach the problem by reusing existing solutions. In the second half of this lecture, we look at a small set of additional standards that were not yet covered.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<part id="xml-alternatives">
			<title>Alternatives to XML</title>
			<slide>
				<title>XML's Capabilities</title>
				<blockquote>If the only tool you have is a hammer, you tend to see every problem as a nail.</blockquote>
				<p class="quotenote"><a href="http://en.wikipedia.org/wiki/Abraham_Maslow">Abraham Maslow</a></p>
				<ul>
					<li>Representation (XML itself, XInclude)</li>
					<li>Management (XDBMS, XQuery)</li>
					<li>Interchange (sharing XML, REST)</li>
					<li>Processing (XSLT, XQuery)</li>
				</ul>
			</slide>
			<part id="json">
				<title short="JSON">JavaScript Object Notation (JSON)</title>
				<slide>
					<title>JSON is the new XML</title>
					<ul>
						<li>XML's tree model is not <q>natural</q> for developers</li>
						<ul>
							<li>developers tend to think in <q>objects</q> or similar concepts</li>
							<li>mapping bidirectionally creates unhappiness and friction</li>
						</ul>
						<li>JSON takes a minimalist approach at representing <q>object structures</q></li>
						<ul>
							<li>the only supported concepts are <a href="http://tools.ietf.org/html/rfc4627#section-2.2">objects (name/value pairs)</a> and <a href="http://tools.ietf.org/html/rfc4627#section-2.3">arrays</a></li>
							<li>these concepts can be nested as deeply as required</li>
						</ul>
						<li>JSON's main reason for success is structural alignment</li>
						<ul>
							<li>most developers can work with JSON <em>directly in their language</em></li>
							<li>XML's more sophisticated features often are not required</li>
						</ul>
						<li>JSON is a poster child of the <a href="http://en.wikipedia.org/wiki/Pareto_principle" title="a.k.a. 80/20 rule">Pareto Principle</a> (or maybe 95/5)</li>
					</ul>
				</slide>
				<slide>
					<title>JSON Example</title>
					<listing src="menu.xml"/>
					<listing src="menu.json"/>
				</slide>
			</part>
			<part id="rdf">
				<title short="RDF">Resource Description Framework (RDF)</title>
				<title>Semantic Web &amp; Linked Data</title>
				<slide>
					<title>Linked Data Principles</title>
					<ol>
						<li>Use URIs as names for things.</li>
						<li>Use HTTP URIs so that people can look up those names.</li>
						<li>When someone looks up a URI, provide useful information, using a standard data model.</li>
						<li>Include links to other URIs, so that people can discover more things.</li>
					</ol>
				</slide>
				<slide>
					<title>URIs as Names</title>
					<ul>
						<li>A URI can identify any abstract concept, not just Web pages</li>
						<li>The Semantic Web is mainly about how to assign URIs to any concept</li>
						<li><a href="http://dbpedia.org/">DBpedia</a> is a project creating URIs for every topic in Wikipedia</li>
						<ul>
							<li>Spoon: <code href="http://dbpedia.org/resource/Spoon_%28band%29">http://dbpedia.org/resource/Spoon_%28band%29</code></li>
							<li>Mysticism: <code href="http://dbpedia.org/resource/Mysticism">http://dbpedia.org/resource/Mysticism</code></li>
						</ul>
						<li>Anyone can create URIs for concepts</li>
						<ul>
							<li>Panthera tigris: <code href="http://lod.taxonconcept.org/ses/QMUrD">http://lod.taxonconcept.org/ses/QMUrD</code></li>
						</ul>
						<li>Multiple people or groups can create URIs for the same concept</li>
						<ul>
							<li>All the <a href="http://sameas.org/html?uri=http%3A%2F%2Flod.geospecies.org%2Fses%2FQMUrD">URIs for Panthera tigris</a></li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>RDF as Semantic Web Foundation</title>
					<ul>
						<li>The standard data model for Semantic Web standards is the <em>Resource Description Framework (RDF)</em></li>
						<li>Data in RDF is just lists of <em>statements</em></li>
						<ul>
							<li>Spoon is a music group</li>
							<li>Spoon is named <q>Spoon</q></li>
							<li>Spoon has a member Britt Daniel</li>
						</ul>
						<li>A statement consists of three parts: [subject] [predicate] [object]</li>
						<ul>
							<li>[Spoon] [is a] [music group]</li>
							<li>[Spoon] [is named] ["Spoon"]</li>
							<li>[Spoon] [has a member] [Britt Daniel]</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Semantic Web Data Model (abstract)</title>
					<img style="height : 70% ; margin : 2% ; " src="rdf-triple.png"/>
				</slide>
				<slide>
					<title>Semantic Web Data Model (URI concepts)</title>
					<img style="height : 70% ; margin : 2% ; " src="rdf-triple-uris.png"/>
				</slide>
				<slide>
					<title>Linking Data Sets</title>
					<img style="height : 70% ; margin : 2% ; " src="lod-cloud.png" href="http://lod-cloud.net/"/>
				</slide>
			</part>
		</part>
		<part id="various-technologies">
			<title>Various XML Technologies</title>
			<part id="infoset">
				<title short="Infoset">XML Information Set (XML Infoset)</title>
				<slide>
					<title>What is the Content of an XML Document?</title>
					<ul>
						<li>An interesting (and fruitless) discussion</li>
						<ul>
							<li>the content is whatever you consider it to be</li>
							<li>agreement between peers is necessary for data exchange</li>
							<li>agreement between specification writers and toolmakers is necessary to provide tools</li>
						</ul>
						<li>DOM and XSLT were two early arrivals</li>
						<ul>
							<li>both had an idea (and a model) of what the content of an XML document is</li>
							<li>they did not have the exact same idea</li>
						</ul>
						<li>Set a normative standard for an XML document's content</li>
						<ul>
							<li>the Infoset defines what is represented in the tree</li>
							<li>people should be confident to get this information when using XML technologies</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Infoset Example</title>
					<img src="infoset-example.png" style="width : 90% ; margin : 4% ; "/>
				</slide>
				<slide id="not-infoset">
					<title>What is <u>Not</u> in the Infoset</title>
					<ul>
						<li>Do not rely on <a href="http://www.w3.org/TR/xml-infoset/#omitted">information not available in the Infoset</a></li>
						<ul>
							<li>order of attributes</li>
							<li>type of quotes around attribute values</li>
							<li>notation of empty elements (<code>&lt;elem>&lt;/elem></code> vs. <code>&lt;elem/></code>)</li>
							<li>how lines are terminated</li>
							<li>entities and character references</li>
						</ul>
						<li>XML contains all this information if used as XML document</li>
						<li>many XML technologies are in fact Infoset technologies</li>
						<ul>
							<li>XSD, XSLT, XQuery, SOAP, …</li>
						</ul>
					</ul>
				</slide>
			</part>
			<part id="xml:id">
				<title short="xml:id">XML IDs with xml:id</title>
				<slide>
					<title>References in Instances</title>
					<ul>
						<li><link href="dtd">DTD</link> and <link href="xsd-1">XSD</link> IDs are defined in the schema</li>
						<ul>
							<li>the important information is the <em>(attribute) type</em> in the schema</li>
							<li>the name of the attribute can be freely chosen by the schema designer</li>
						</ul>
						<li><a href="http://www.w3.org/TR/xml-id/" title='W3C "xml:id" Spec'>xml:id</a> establishes a well-know attribute name for IDs</li>
						<ul>
							<li>the <q>IDness</q> of an attribute is established by its name</li>
							<li>IDs can be found without any schema (there does not even has to be one)</li>
						</ul>
						<li><code>xml:id</code> uses XML's own namespace to identify identifiers</li>
						<ul>
							<li>only W3C-blessed specifications are allowed to extend the XML namespace</li>
							<li><code href="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</code> contains a mix of various specs</li>
						</ul>
					</ul>
					<pre>&lt;section id="introduction"></pre>
					<pre>&lt;section xml:id="introduction"></pre>
				</slide>
			</part>
			<part id="xinclude">
				<title short="XInclude">XML Inclusions (XInclude)</title>
				<slide>
					<title>Including Trees into Trees</title>
					<ul>
						<li><a href="http://www.w3.org/TR/xinclude/" title='W3C "XML Inclusions (XInclude)" Spec'>XInclude</a> defines an inclusion facility for XML</li>
						<ul>
							<li>it is a separate standard and not part of XML itself</li>
							<li>XML processors might or might not support XInclude</li>
						</ul>
						<li>XInclude is defined as replacing XInclude elements with included content</li>
						<ul>
							<li>logically speaking, XInclude is thus defined as a tree transformation</li>
							<li>practically speaking, it can thus be <a href="http://dret.net/projects/xipr/">implemented in XSLT</a></li>
						</ul>
					</ul>
					<pre>&lt;x xmlns:xi="http://www.w3.org/2001/XInclude">
	&lt;xi:include href="something.xml"/>
	&lt;xi:include xpointer="xmlns(xi=http://www.w3.org/2001/XInclude)xpointer(x/xi:include[1])" parse="xml"/>
&lt;/x></pre>
				</slide>
				<slide>
					<title>XInclude Schema</title>
					<pre>&lt;!ELEMENT xi:include (xi:fallback?)>
&lt;!ATTLIST xi:include
	xmlns:xi		CDATA	   #FIXED	"http://www.w3.org/2001/XInclude"
	href			CDATA	   #IMPLIED
	parse		   (xml|text)  "xml"
	xpointer		CDATA	   #IMPLIED
	encoding		CDATA	   #IMPLIED
	accept		  CDATA	   #IMPLIED
	accept-language CDATA	   #IMPLIED
></pre>
				</slide>
			</part>
			<part id="xml-processing">
				<title>Processing XML</title>
				<slide>
					<title>XML and Programming</title>
					<ul>
						<li>XML is a format for structured data</li>
						<ul>
							<li>trees do not map very well to most programming languages</li>
							<li>for working with XML, some mapping into the language is required</li>
						</ul>
						<li>There are two basic approaches for programming with XML:</li>
						<ol>
							<li>use special functions to work on XML documents as external data objects</li>
							<li>map XML documents to native data structures of the programming language</li>
						</ol>
						<li>A third approach is to have an <q>XML programming language</q></li>
						<ul>
							<li><link href="xslt-1">XSLT</link> is an example for an XML programming language</li>
							<li><link href="xsd-1">XSD</link> and <link href="xpath">XPath</link> become an integral part of Java in <a href="http://www.research.ibm.com/xj/">XJ</a></li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>XML and Programming Languages</title>
					<ul>
						<li>Most programming languages do not support XML natively</li>
						<ul>
							<li>a certain impedance mismatch between both models in unavoidable</li>
						</ul>
						<li>Function libraries (or their equivalent) can provide XML processing facilities</li>
						<ul>
							<li><link href="sax">SAX</link> as an event-based API for accessing XML documents</li>
							<li><link href="dom">DOM</link> as a tree-based API for accessing XML documents</li>
						</ul>
						<li>Mapping between XML and the programming language can take two forms</li>
						<ul>
							<li>using hand-crafted code (based on XML functions) that performs the mapping</li>
							<li>generating code using an XML schema and/or target data structures in the language</li>
						</ul>
						<li>Generating mapping code can be done in two ways</li>
						<ul>
							<li>using a generic <link href="databinding"/> framework for the mapping</li>
							<li>using hand-crafted code that can be better tailored to the schemas</li>
						</ul>
					</ul>
				</slide>
				<slide>
					<title>Typical XML &amp; Programming Problem</title>
					<ul>
						<li><a href="../web-fall10/ajax">Asynchronous JavaScript and XML (Ajax)</a> is based on HTTP &amp; XML</li>
						<ul>
							<li>JavaScript code can communicate with the server using <code href="http://www.w3.org/TR/XMLHttpRequest/" title="W3C XMLHttpRequest Spec">XMLHttpRequest</code></li>
							<li>in theory, the server sends XML data which is processed by the script</li>
						</ul>
						<li>XML parsing and processing is inconvenient in JavaScript</li>
						<ul>
							<li>there is a impedance mismatch between JavaScript and XML</li>
							<li>if the client is slow and the XML is big, parsing can be time-consuming</li>
							<li>if all clients are JavaScript, then sending XML is not really necessary</li>
						</ul>
						<li><em>JavaScript Object Notation (JSON)</em> is a JavaScript-centric data model</li>
						<ul>
							<li>JavaScript code can directly instantiate JSON structures as runtime objects</li>
							<li>any non-JavaScript client (if there are any) will have to use JSON as well</li>
						</ul>
					</ul>
				</slide>
				<part id="sax">
					<title>Simple API for XML (SAX)</title>
					<slide>
						<title>Lightweight XML Processing</title>
						<ul>
							<li>SAX is an event-based API for accessing XML documents</li>
							<li>SAX allows users to use event handlers for parsing-related events</li>
							<ul>
								<li>the parser reads a document and recognizes markup structures</li>
								<li>for each recognized structure, a user-supplied function can be called</li>
							</ul>
							<li>SAX parsing requires little memory and can handle very large documents</li>
							<ul>
								<li>the breadth of the XML document tree is irrelevant to SAX parsing</li>
								<li>the depth of the tree is relevant for checking for well-formed documents</li>
							</ul>
							<li>SAX parsing does not allow random access or backward movement</li>
							<ul>
								<li>saving context and history is something the application has to manage</li>
								<li>at a certain complexity, SAX parsing requires a lot of additional code</li>
							</ul>
						</ul>
					</slide>
					<slide>
						<title>SAX Parser</title>
						<img style="width : 90% ; margin : 2% ; " src="sax-parser.png" title="SAX Parser"/>
					</slide>
				</part>
				<part id="dom">
					<title>Document Object Model (DOM)</title>
					<slide>
						<title>XML Trees Everywhere</title>
						<ul>
							<li>DOM is a tree-based API for accessing XML documents</li>
							<ul>
								<li>the specification using a <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/idl-definitions.html">language-independent <em>Interface Definition Language (IDL)</em></a> </li>
								<li><q>language bindings</q> map IDL to specific languages such as <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/java-binding.html">Java</a> or <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/ecma-script-binding.html">JavaScript</a></li>
							</ul>
							<li>DOM is based on an in-memory representation of an XML document</li>
							<ul>
								<li>random document access using <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1950641247">the tree's node structure</a></li>
								<li>more specific tasks such as <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-217A91B8">getting an element's attribute by name</a></li>
							</ul>
							<li>DOM parsers have an additional layer for building the tree</li>
							<ul>
								<li>an underlying SAX parser reports structures for tree building</li>
								<li>the memory representation is heavily interlinked (requiring substantial memory)</li>
								<li>DOM calls query or modify the memory representation of the tree</li>
							</ul>
							<li>DOM processing is not appropriate for all tasks</li>
							<ul>
								<li>very large documents may not fit into memory (risk of <em>thrashing</em>)</li>
								<li>for isolated tasks, the parsing overhead is prohibitive</li>
							</ul>
						</ul>
					</slide>
					<slide>
						<title>DOM Parser</title>
						<img style="width : 90% ; margin : 2% ; " src="dom-parser.png" title="DOM Parser"/>
					</slide>
					<slide id="jdom">
						<title>JDOM</title>
						<ul>
							<li>DOM is not optimized for a specific programming language</li>
							<ul>
								<li>DOM knowledge can be easily transferred between programming languages</li>
								<li>programming with DOM in a given language often is not very convenient</li>
							</ul>
							<li>JDOM is a Java-specific version of a tree-based XML API</li>
							<ul>
								<li>represents the same concepts as DOM (XML structures)</li>
								<li>represents XML concepts <a href="http://www-128.ibm.com/developerworks/java/library/j-jdom/#h2">in a more Java-friendly way</a></li>
								<li>JDOM has no relationship with the W3C's DOM API</li>
							</ul>
							<li>JDOM can be built on top of almost any parser</li>
							<ul>
								<li>SAX is a pretty common choice for a foundation for JDOM</li>
								<li>SAX events are then used to build the JDOM tree</li>
							</ul>
						</ul>
					</slide>
				</part>
				<part id="databinding">
					<title>XML Data Binding</title>
					<slide>
						<title>Mapping XML into Languages</title>
						<ul>
							<li>XML data binding connects XML with language-specific structures</li>
							<ul>
								<li>for OO languages this often means mapping schemas and classes</li>
								<li>code for serialization and deserialization can then be generated</li>
							</ul>
							<li>Typical problems of data binding are schema changes</li>
							<ul>
								<li>if the schema is updated, can the code be migrated easily?</li>
								<li>can instances of different versions be handled by the same code?</li>
								<li>most data binding frameworks do not fully support XSD anyway</li>
							</ul>
							<li>Several XML data binding frameworks are in widespread use</li>
							<ul>
								<li><a href="https://jaxb.dev.java.net/">Java Architecture for XML Binding (JAXB)</a></li>
								<li>Castor, another Java-based data binding framework</li>
							</ul>
						</ul>
					</slide>
				</part>
			</part>
		</part>
	</presentation>
	<presentation id="summary">
		<title short="Summary">Course Summary</title>
		<date>2013-12-11</date>
		<toc class="resources"></toc>
		<toc class="abstract">Q&amp;A with a short discussion of the course topics, followed by questions about topics, standards, technologies, and exam issues.</toc>
		<slide>
			<title>Abstract</title>
			<p class="abstract"><toc class="abstract"/></p>
		</slide>
		<slide>
			<title>Course Topics</title>
			<ul>
				<li><link href="basics">XML Basics how to use them</link></li>
				<li><link href="dtd">Describing classes of XML documents</link></li>
				<li><link href="xmlns">Combining different vocabularies of XML documents</link></li>
				<li><link href="xpath">Selecting parts of an XML document</link></li>
				<li><link href="xslt-1">Transforming XML into something else (or XML again)</link></li>
				<li><link href="xsd-1">A more complicated way to describe classes of XML documents</link></li>
				<li><link href="relax-ng">Alternative ways of describing classes of XML documents</link></li>
				<li><link href="xquery-1">Querying XML with a dedicated query language</link></li>
				<li><link href="xdb">Managing XML in a dedicated XML database</link></li>
			</ul>
		</slide>
		<slide>
			<title>Exam Format</title>
			<ul>
				<li>Do not waste time and energy memorizing data</li>
				<li>What matters is <em>understanding and connecting concepts</em></li>
				<li>You may be asked to comment on certain designs</li>
				<li>You may be asked to propose certain designs</li>
				<li>Which technology to choose for a certain problem?</li>
				<li>The goal is to know what XML is and isn't good/useful for</li>
			</ul>
		</slide>
	</presentation>
</hotspot>